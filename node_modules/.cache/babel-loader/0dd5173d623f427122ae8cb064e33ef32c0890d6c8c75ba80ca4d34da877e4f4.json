{"ast":null,"code":"var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: cb => (promise || (promise = Promise.resolve())).then(cb).catch(err => setTimeout(() => {\n  throw err;\n}, 0));\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED$2 = \"UPDATED\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED$2);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant$1(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe$1 = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe$1 = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject$1 = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep$1 = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject$1(target) && isObject$1(source)) {\n    for (const key in source) {\n      if (isObject$1(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep$1(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep$1(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs$1 = value => Array.isArray(value) ? mergeDeep$1({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts$1 = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress$1 = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress$1 = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts$1 = (jsons, network) => {\n  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal$1 = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys$1 = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal$1(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys$1 = value => {\n  if (isObject$1(value)) return hasPrivateKeys$1(value);\n  return value.some(hasPrivateKeys$1);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork$1 = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME$1 = \"config\";\nconst PUT$1 = \"PUT_CONFIG\";\nconst GET$1 = \"GET_CONFIG\";\nconst GET_ALL$1 = \"GET_ALL_CONFIG\";\nconst UPDATE$1 = \"UPDATE_CONFIG\";\nconst DELETE$1 = \"DELETE_CONFIG\";\nconst CLEAR$1 = \"CLEAR_CONFIG\";\nconst WHERE$1 = \"WHERE_CONFIG\";\nconst UPDATED$1 = \"CONFIG/UPDATED\";\nconst identity$1 = v => v;\nconst HANDLERS$1 = {\n  [PUT$1]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [GET$1]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL$1]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE$1]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity$1);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [DELETE$1]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR$1]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [WHERE$1]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED$1, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS$1, NAME$1);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put$1(key, value) {\n  send(NAME$1, PUT$1, {\n    key,\n    value\n  });\n  return config$1();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get$1(key, fallback) {\n  return send(NAME$1, GET$1, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first$1() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get$1(head);\n  if (ret == null) return first$1(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all$1() {\n  return send(NAME$1, GET_ALL$1, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update$1(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  send(NAME$1, UPDATE$1, {\n    key,\n    fn\n  });\n  return config$1();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete$1(key) {\n  send(NAME$1, DELETE$1, {\n    key\n  });\n  return config$1();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where$1(pattern) {\n  return send(NAME$1, WHERE$1, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe$1(callback) {\n  return subscriber(NAME$1, () => spawn(HANDLERS$1, NAME$1), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig$1() {\n  return send(NAME$1, CLEAR$1);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig$1(oldConfig) {\n  return clearConfig$1().then(config$1(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load$1(data) {\n  const network = await get$1(\"flow.network\");\n  const cleanedNetwork = cleanNetwork$1(network);\n  const {\n    flowJSON\n  } = data;\n  invariant$1(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant$1(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys$1(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts$1(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get$1(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get$1(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put$1(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config$1(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put$1(d, values[d]));\n  }\n  return {\n    put: put$1,\n    get: get$1,\n    all: all$1,\n    first: first$1,\n    update: update$1,\n    delete: _delete$1,\n    where: where$1,\n    subscribe: subscribe$1,\n    overload: overload$1,\n    load: load$1\n  };\n}\nconfig$1.put = put$1;\nconfig$1.get = get$1;\nconfig$1.all = all$1;\nconfig$1.first = first$1;\nconfig$1.update = update$1;\nconfig$1.delete = _delete$1;\nconfig$1.where = where$1;\nconfig$1.subscribe = subscribe$1;\nconfig$1.overload = overload$1;\nconfig$1.load = load$1;\nconst noop$1 = v => v;\nfunction overload$1() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all$1();\n    try {\n      config$1(opts);\n      var result = await callback(await all$1());\n      await resetConfig$1(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig$1(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS$1 = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs$1 = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log$1 = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config$1.get(\"logger.level\", LEVELS$1.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs$1({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS$1.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS$1.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS$1.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS$1.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog$1.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS$1.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log$1({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`);\n    error.stack = error.stack.split(\"\\n\").filter(d => !/at invariant/.test(d)).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\");\n    throw error;\n  }\n}\nconst pipe = function () {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe = function () {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return v => {\n    return funcs.reduce((res, func) => {\n      return {\n        ...res,\n        ...func(v)\n      };\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value => value && typeof value === \"object\" && !Array.isArray(value);\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = function (target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value => Array.isArray(value) ? mergeDeep({}, ...value) : value;\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => obj.contracts ? obj.contracts : {};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, _ref) => {\n    let [key, value] = _ref;\n    const networkContractAlias = value?.aliases?.[network];\n    if (networkContractAlias) {\n      c[key] = networkContractAlias;\n    }\n    return c;\n  }, {});\n};\nconst mapDeploymentsToNetworkAddress = network => _ref2 => {\n  let {\n    deployments = {},\n    accounts = {}\n  } = _ref2;\n  const networkDeployment = deployments?.[network];\n  if (!networkDeployment) return {};\n  return Object.entries(networkDeployment).reduce((c, _ref3) => {\n    let [key, value] = _ref3;\n    // Resolve account address\n    const accountAddress = accounts[key]?.address;\n    if (!accountAddress) return c;\n\n    // Create an object assigning the address to the contract name.\n    return value.reduce((c, contract) => {\n      return {\n        ...c,\n        [contract]: accountAddress\n      };\n    }, {});\n  }, {});\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst getContracts = (jsons, network) => {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce((hasPrivateKey, _ref4) => {\n    let [key, value] = _ref4;\n    if (hasPrivateKey) return true;\n    return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nconst anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nconst cleanNetwork = network => network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase();\nconst NAME = \"config\";\nconst PUT = \"PUT_CONFIG\";\nconst GET = \"GET_CONFIG\";\nconst GET_ALL = \"GET_ALL_CONFIG\";\nconst UPDATE = \"UPDATE_CONFIG\";\nconst DELETE = \"DELETE_CONFIG\";\nconst CLEAR = \"CLEAR_CONFIG\";\nconst WHERE = \"WHERE_CONFIG\";\nconst UPDATED = \"CONFIG/UPDATED\";\nconst identity = v => v;\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, _ref) => {\n    let {\n      key,\n      value\n    } = _ref;\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n    ctx.put(key, value);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [GET]: (ctx, letter, _ref2) => {\n    let {\n      key,\n      fallback\n    } = _ref2;\n    if (key == null) throw new Error(\"Missing 'key' for config/get\");\n    letter.reply(ctx.get(key, fallback));\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({\n      ...ctx.all()\n    });\n  },\n  [UPDATE]: (ctx, letter, _ref3) => {\n    let {\n      key,\n      fn\n    } = _ref3;\n    if (key == null) throw new Error(\"Missing 'key' for config/update\");\n    ctx.update(key, fn || identity);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [DELETE]: (ctx, letter, _ref4) => {\n    let {\n      key\n    } = _ref4;\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n    ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all());\n    for (let key of keys) ctx.delete(key);\n    ctx.broadcast(UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [WHERE]: (ctx, letter, _ref5) => {\n    let {\n      pattern\n    } = _ref5;\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n    letter.reply(ctx.where(pattern));\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from);\n    ctx.send(letter.from, UPDATED, {\n      ...ctx.all()\n    });\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from);\n  }\n};\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key,\n    value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key,\n    fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first() {\n  let wants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let fallback = arguments.length > 1 ? arguments[1] : undefined;\n  if (!wants.length) return fallback;\n  const [head, ...rest] = wants;\n  const ret = await get(head);\n  if (ret == null) return first(rest, fallback);\n  return ret;\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  let fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key,\n    fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\");\n  const cleanedNetwork = cleanNetwork(network);\n  const {\n    flowJSON\n  } = data;\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n  invariant(cleanedNetwork, `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`);\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\";\n    log$1({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n    });\n    if (!isEmulator) return;\n  }\n  for (const [key, value] of Object.entries(getContracts(flowJSON, cleanedNetwork))) {\n    const contractConfigKey = `0x${key}`;\n    const existingContractConfigKey = await get(contractConfigKey);\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(contractConfigKey, value);\n    }\n    const systemContractConfigKey = `system.contracts.${key}`;\n    const systemExistingContractConfigKeyValue = await get(systemContractConfigKey);\n    if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n      log$1({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: LEVELS$1.warn\n      });\n    } else {\n      put(systemContractConfigKey, value);\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]));\n  }\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nconst noop = v => v;\nfunction overload() {\n  let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all();\n    try {\n      config(opts);\n      var result = await callback(await all());\n      await resetConfig(oldConfig);\n      resolve(result);\n    } catch (error) {\n      await resetConfig(oldConfig);\n      reject(error);\n    }\n  });\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nconst LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = _ref => {\n  let {\n    title,\n    message\n  } = _ref;\n  return [`\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `.replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nconst log = async _ref2 => {\n  let {\n    title,\n    message,\n    level,\n    always = false\n  } = _ref2;\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn);\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return;\n  const loggerMessageArgs = buildLoggerMessageArgs({\n    title,\n    message\n  });\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs);\n      break;\n    case LEVELS.info:\n      console.info(...loggerMessageArgs);\n      break;\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs);\n      break;\n    case LEVELS.error:\n      console.error(...loggerMessageArgs);\n      break;\n    default:\n      console.log(...loggerMessageArgs);\n  }\n};\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = _ref3 => {\n  let {\n    pkg,\n    subject,\n    transition,\n    level = LEVELS.warn,\n    message = \"\",\n    callback = null\n  } = _ref3;\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  const logMessage = () => log({\n    title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n    message: `\n      ${subject ? `${capitalizeFirstLetter(subject)} is deprecated and will cease to work in future releases${pkg ? \" of \" + pkg : \"\"}.` : \"\"}${message ? \"\\n\" + message : \"\"}${transition ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}` : \"\"}\n    `.trim(),\n    level\n  });\n  if (typeof callback === \"function\") {\n    return async function () {\n      await logMessage();\n      return await callback(...arguments);\n    };\n  }\n  return logMessage();\n};\nfunction interleave() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!a.length && !b.length) return c;\n  if (!a.length) return c;\n  if (!b.length) return [...c, a[0]];\n  const [aHead, ...aRest] = a;\n  const [bHead, ...bRest] = b;\n  if (aHead !== undefined) c.push(aHead);\n  if (bHead !== undefined) c.push(bHead);\n  return interleave(aRest, bRest, c);\n}\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\"\n      });\n      return recApply(d)(arg1(d));\n    }\n    return String(arg1);\n  };\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nfunction template(head) {\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n  if (typeof head === \"string\") return () => head;\n  if (Array.isArray(head)) {\n    return d => interleave(head, rest.map(recApply(d))).join(\"\").trim();\n  }\n  return head;\n}\nexport { interleave, template };","map":{"version":3,"names":["promise","queueMicrotask_1","queueMicrotask","bind","window","commonjsGlobal","cb","Promise","resolve","then","catch","err","setTimeout","next","deliver","msg","queue","push","shift","undefined","receive","innerReceive","fact","error","Error","stack","split","filter","d","test","join","console","rest","invariant","_len","arguments","length","Array","_key","LEVELS","Object","freeze","debug","info","log","warn","buildLoggerMessageArgs","_ref","title","message","replace","trim","_ref2","level","always","configLoggerLevel","config","get","loggerMessageArgs","deprecate","_ref3","pkg","subject","transition","callback","capitalizeFirstLetter","string","charAt","toUpperCase","slice","logMessage","interleave","a","b","c","aHead","aRest","bHead","bRest","recApply","arg1","String","template","head","isArray","map"],"sources":["/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/node_modules/queue-microtask/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-actor/src/mailbox/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-invariant/src/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-logger/src/util-logger.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-template/src/template.js"],"sourcesContent":["/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nexport function invariant(fact, msg, ...rest) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`)\n    error.stack = error.stack\n      .split(\"\\n\")\n      .filter(d => !/at invariant/.test(d))\n      .join(\"\\n\")\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\")\n    throw error\n  }\n}\n","import {config} from \"@onflow/config\"\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nexport const LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1,\n})\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = ({title, message}) => {\n  return [\n    `\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `\n      .replace(/\\n[^\\S\\r\\n]+/g, \"\\n\")\n      .trim(),\n    ,\n    \"font-weight:bold;font-family:monospace;\",\n  ]\n}\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nexport const log = async ({title, message, level, always = false}) => {\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn)\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return\n\n  const loggerMessageArgs = buildLoggerMessageArgs({title, message})\n\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs)\n      break\n    case LEVELS.info:\n      console.info(...loggerMessageArgs)\n      break\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs)\n      break\n    case LEVELS.error:\n      console.error(...loggerMessageArgs)\n      break\n    default:\n      console.log(...loggerMessageArgs)\n  }\n}\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = ({\n  pkg,\n  subject,\n  transition,\n  level = LEVELS.warn,\n  message = \"\",\n  callback = null,\n}) => {\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1)\n  }\n\n  const logMessage = () =>\n    log({\n      title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n      message: `\n      ${\n        subject\n          ? `${capitalizeFirstLetter(\n              subject\n            )} is deprecated and will cease to work in future releases${\n              pkg ? \" of \" + pkg : \"\"\n            }.`\n          : \"\"\n      }${message ? \"\\n\" + message : \"\"}${\n        transition\n          ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}`\n          : \"\"\n      }\n    `.trim(),\n      level,\n    })\n\n  if (typeof callback === \"function\") {\n    return async (...args) => {\n      await logMessage()\n      return await callback(...args)\n    }\n  }\n  return logMessage()\n}\n","import {log} from \"@onflow/util-logger\"\n\nexport function interleave(a = [], b = [], c = []) {\n  if (!a.length && !b.length) return c\n  if (!a.length) return c\n  if (!b.length) return [...c, a[0]]\n\n  const [aHead, ...aRest] = a\n  const [bHead, ...bRest] = b\n\n  if (aHead !== undefined) c.push(aHead)\n  if (bHead !== undefined) c.push(bHead)\n\n  return interleave(aRest, bRest, c)\n}\n\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition:\n          \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n      })\n      return recApply(d)(arg1(d))\n    }\n    return String(arg1)\n  }\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nexport function template(head, ...rest) {\n  if (typeof head === \"string\") return () => head\n  if (Array.isArray(head)) {\n    return d =>\n      interleave(head, rest.map(recApply(d)))\n        .join(\"\")\n        .trim()\n  }\n  return head\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}