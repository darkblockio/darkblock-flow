{"ast":null,"code":"import _toArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _regeneratorRuntime from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _HANDLERS$, _HANDLERS;\nimport { spawn, SUBSCRIBE, UNSUBSCRIBE, send, subscriber } from '@onflow/util-actor';\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant$1(fact, msg) {\n  if (!fact) {\n    var _console;\n    var error = new Error(\"INVARIANT \".concat(msg));\n    error.stack = error.stack.split(\"\\n\").filter(function (d) {\n      return !/at invariant/.test(d);\n    }).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    (_console = console).error.apply(_console, [\"\\n\\n---\\n\\n\", error, \"\\n\\n\"].concat(rest, [\"\\n\\n---\\n\\n\"]));\n    throw error;\n  }\n}\nvar pipe$1 = function pipe$1() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nvar mergePipe$1 = function mergePipe$1() {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return _objectSpread(_objectSpread({}, res), func(v));\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nvar isObject$1 = function isObject$1(value) {\n  return value && typeof value === \"object\" && !Array.isArray(value);\n};\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nvar mergeDeep$1 = function mergeDeep$1(target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  var source = sources.shift();\n  if (isObject$1(target) && isObject$1(source)) {\n    for (var key in source) {\n      if (isObject$1(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep$1(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return mergeDeep$1.apply(void 0, [target].concat(sources));\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nvar mergeFlowJSONs$1 = function mergeFlowJSONs$1(value) {\n  return Array.isArray(value) ? mergeDeep$1.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;\n};\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nvar filterContracts$1 = function filterContracts$1(obj) {\n  return obj.contracts ? obj.contracts : {};\n};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar mapContractAliasesToNetworkAddress$1 = function mapContractAliasesToNetworkAddress$1(network) {\n  return function (contracts) {\n    return Object.entries(contracts).reduce(function (c, _ref) {\n      var _value$aliases;\n      var _ref6 = _slicedToArray(_ref, 2),\n        key = _ref6[0],\n        value = _ref6[1];\n      var networkContractAlias = value === null || value === void 0 || (_value$aliases = value.aliases) === null || _value$aliases === void 0 ? void 0 : _value$aliases[network];\n      if (networkContractAlias) {\n        c[key] = networkContractAlias;\n      }\n      return c;\n    }, {});\n  };\n};\nvar mapDeploymentsToNetworkAddress$1 = function mapDeploymentsToNetworkAddress$1(network) {\n  return function (_ref2) {\n    var _ref2$deployments = _ref2.deployments,\n      deployments = _ref2$deployments === void 0 ? {} : _ref2$deployments,\n      _ref2$accounts = _ref2.accounts,\n      accounts = _ref2$accounts === void 0 ? {} : _ref2$accounts;\n    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];\n    if (!networkDeployment) return {};\n    return Object.entries(networkDeployment).reduce(function (c, _ref3) {\n      var _accounts$key;\n      var _ref7 = _slicedToArray(_ref3, 2),\n        key = _ref7[0],\n        value = _ref7[1];\n      // Resolve account address\n      var accountAddress = (_accounts$key = accounts[key]) === null || _accounts$key === void 0 ? void 0 : _accounts$key.address;\n      if (!accountAddress) return c;\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce(function (c, contract) {\n        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));\n      }, {});\n    }, {});\n  };\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar getContracts$1 = function getContracts$1(jsons, network) {\n  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nvar isHexidecimal$1 = function isHexidecimal$1(str) {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nvar hasPrivateKeys$1 = function hasPrivateKeys$1(flowJSON) {\n  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref4) {\n    var _ref8 = _slicedToArray(_ref4, 2),\n      key = _ref8[0],\n      value = _ref8[1];\n    if (hasPrivateKey) return true;\n    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty(\"key\")) && isHexidecimal$1(value === null || value === void 0 ? void 0 : value.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nvar anyHasPrivateKeys$1 = function anyHasPrivateKeys$1(value) {\n  if (isObject$1(value)) return hasPrivateKeys$1(value);\n  return value.some(hasPrivateKeys$1);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nvar cleanNetwork$1 = function cleanNetwork$1(network) {\n  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === \"local\" ? \"emulator\" : network === null || network === void 0 ? void 0 : network.toLowerCase();\n};\nvar NAME$1 = \"config\";\nvar PUT$1 = \"PUT_CONFIG\";\nvar GET$1 = \"GET_CONFIG\";\nvar GET_ALL$1 = \"GET_ALL_CONFIG\";\nvar UPDATE$1 = \"UPDATE_CONFIG\";\nvar DELETE$1 = \"DELETE_CONFIG\";\nvar CLEAR$1 = \"CLEAR_CONFIG\";\nvar WHERE$1 = \"WHERE_CONFIG\";\nvar UPDATED$1 = \"CONFIG/UPDATED\";\nvar identity$1 = function identity$1(v) {\n  return v;\n};\nvar HANDLERS$1 = (_HANDLERS$ = {}, _defineProperty(_HANDLERS$, PUT$1, function (ctx, _letter, _ref) {\n  var key = _ref.key,\n    value = _ref.value;\n  if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n  ctx.put(key, value);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, GET$1, function (ctx, letter, _ref2) {\n  var key = _ref2.key,\n    fallback = _ref2.fallback;\n  if (key == null) throw new Error(\"Missing 'key' for config/get\");\n  letter.reply(ctx.get(key, fallback));\n}), _defineProperty(_HANDLERS$, GET_ALL$1, function (ctx, letter) {\n  letter.reply(_objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, UPDATE$1, function (ctx, letter, _ref3) {\n  var key = _ref3.key,\n    fn = _ref3.fn;\n  if (key == null) throw new Error(\"Missing 'key' for config/update\");\n  ctx.update(key, fn || identity$1);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, DELETE$1, function (ctx, letter, _ref4) {\n  var key = _ref4.key;\n  if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n  ctx.delete(key);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, CLEAR$1, function (ctx, letter) {\n  var keys = Object.keys(ctx.all());\n  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n    var key = _keys[_i];\n    ctx.delete(key);\n  }\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, WHERE$1, function (ctx, letter, _ref5) {\n  var pattern = _ref5.pattern;\n  if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n  letter.reply(ctx.where(pattern));\n}), _defineProperty(_HANDLERS$, SUBSCRIBE, function (ctx, letter) {\n  ctx.subscribe(letter.from);\n  ctx.send(letter.from, UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, UNSUBSCRIBE, function (ctx, letter) {\n  ctx.unsubscribe(letter.from);\n}), _HANDLERS$);\nspawn(HANDLERS$1, NAME$1);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put$1(key, value) {\n  send(NAME$1, PUT$1, {\n    key: key,\n    value: value\n  });\n  return config$1();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get$1(key, fallback) {\n  return send(NAME$1, GET$1, {\n    key: key,\n    fallback: fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction first$1() {\n  return _first$.apply(this, arguments);\n}\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction _first$() {\n  _first$ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n    var wants,\n      fallback,\n      _wants,\n      head,\n      rest,\n      ret,\n      _args5 = arguments;\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) switch (_context5.prev = _context5.next) {\n        case 0:\n          wants = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : [];\n          fallback = _args5.length > 1 ? _args5[1] : undefined;\n          if (wants.length) {\n            _context5.next = 4;\n            break;\n          }\n          return _context5.abrupt(\"return\", fallback);\n        case 4:\n          _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);\n          _context5.next = 7;\n          return get$1(head);\n        case 7:\n          ret = _context5.sent;\n          if (!(ret == null)) {\n            _context5.next = 10;\n            break;\n          }\n          return _context5.abrupt(\"return\", first$1(rest, fallback));\n        case 10:\n          return _context5.abrupt(\"return\", ret);\n        case 11:\n        case \"end\":\n          return _context5.stop();\n      }\n    }, _callee5);\n  }));\n  return _first$.apply(this, arguments);\n}\nfunction all$1() {\n  return send(NAME$1, GET_ALL$1, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update$1(key) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  send(NAME$1, UPDATE$1, {\n    key: key,\n    fn: fn\n  });\n  return config$1();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete$1(key) {\n  send(NAME$1, DELETE$1, {\n    key: key\n  });\n  return config$1();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where$1(pattern) {\n  return send(NAME$1, WHERE$1, {\n    pattern: pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe$1(callback) {\n  return subscriber(NAME$1, function () {\n    return spawn(HANDLERS$1, NAME$1);\n  }, callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig$1() {\n  return send(NAME$1, CLEAR$1);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig$1(oldConfig) {\n  return clearConfig$1().then(config$1(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nfunction load$1(_x) {\n  return _load$.apply(this, arguments);\n} // eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction _load$() {\n  _load$ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(data) {\n    var network, cleanedNetwork, flowJSON, isEmulator, _i3, _Object$entries, _Object$entries$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.next = 2;\n          return get$1(\"flow.network\");\n        case 2:\n          network = _context6.sent;\n          cleanedNetwork = cleanNetwork$1(network);\n          flowJSON = data.flowJSON;\n          invariant$1(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n          invariant$1(cleanedNetwork, \"Flow Network Required -- In order for FCL to load your contracts please define \\\"flow.network\\\" to \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl\");\n          if (!anyHasPrivateKeys$1(flowJSON)) {\n            _context6.next = 12;\n            break;\n          }\n          isEmulator = cleanedNetwork === \"emulator\";\n          log({\n            title: \"Private Keys Detected\",\n            message: \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\",\n            level: isEmulator ? LEVELS.warn : LEVELS.error\n          });\n          if (isEmulator) {\n            _context6.next = 12;\n            break;\n          }\n          return _context6.abrupt(\"return\");\n        case 12:\n          _i3 = 0, _Object$entries = Object.entries(getContracts$1(flowJSON, cleanedNetwork));\n        case 13:\n          if (!(_i3 < _Object$entries.length)) {\n            _context6.next = 28;\n            break;\n          }\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];\n          contractConfigKey = \"0x\".concat(key);\n          _context6.next = 18;\n          return get$1(contractConfigKey);\n        case 18:\n          existingContractConfigKey = _context6.sent;\n          if (existingContractConfigKey && existingContractConfigKey !== value) {\n            log({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS.warn\n            });\n          } else {\n            put$1(contractConfigKey, value);\n          }\n          systemContractConfigKey = \"system.contracts.\".concat(key);\n          _context6.next = 23;\n          return get$1(systemContractConfigKey);\n        case 23:\n          systemExistingContractConfigKeyValue = _context6.sent;\n          if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n            log({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS.warn\n            });\n          } else {\n            put$1(systemContractConfigKey, value);\n          }\n        case 25:\n          _i3++;\n          _context6.next = 13;\n          break;\n        case 28:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return _load$.apply(this, arguments);\n}\nfunction config$1(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(function (d) {\n      return put$1(d, values[d]);\n    });\n  }\n  return {\n    put: put$1,\n    get: get$1,\n    all: all$1,\n    first: first$1,\n    update: update$1,\n    delete: _delete$1,\n    where: where$1,\n    subscribe: subscribe$1,\n    overload: overload$1,\n    load: load$1\n  };\n}\nconfig$1.put = put$1;\nconfig$1.get = get$1;\nconfig$1.all = all$1;\nconfig$1.first = first$1;\nconfig$1.update = update$1;\nconfig$1.delete = _delete$1;\nconfig$1.where = where$1;\nconfig$1.subscribe = subscribe$1;\nconfig$1.overload = overload$1;\nconfig$1.load = load$1;\nvar noop$1 = function noop$1(v) {\n  return v;\n};\nfunction overload$1() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {\n      var oldConfig, result;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return all$1();\n          case 2:\n            oldConfig = _context.sent;\n            _context.prev = 3;\n            config$1(opts);\n            _context.t0 = callback;\n            _context.next = 8;\n            return all$1();\n          case 8:\n            _context.t1 = _context.sent;\n            _context.next = 11;\n            return (0, _context.t0)(_context.t1);\n          case 11:\n            result = _context.sent;\n            _context.next = 14;\n            return resetConfig$1(oldConfig);\n          case 14:\n            resolve(result);\n            _context.next = 22;\n            break;\n          case 17:\n            _context.prev = 17;\n            _context.t2 = _context[\"catch\"](3);\n            _context.next = 21;\n            return resetConfig$1(oldConfig);\n          case 21:\n            reject(_context.t2);\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[3, 17]]);\n    }));\n    return function (_x2, _x3) {\n      return _ref9.apply(this, arguments);\n    };\n  }());\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nvar LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nvar buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {\n  var title = _ref.title,\n    message = _ref.message;\n  return [\"\\n    %c\".concat(title, \"\\n    ============================\\n\\n    \").concat(message, \"\\n\\n    ============================\\n    \").replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nvar log = /*#__PURE__*/function () {\n  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref2) {\n    var _console2, _console3, _console4, _console5, _console6;\n    var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;\n          _context2.next = 3;\n          return config$1.get(\"logger.level\", LEVELS.warn);\n        case 3:\n          configLoggerLevel = _context2.sent;\n          if (!(!always && configLoggerLevel < level)) {\n            _context2.next = 6;\n            break;\n          }\n          return _context2.abrupt(\"return\");\n        case 6:\n          loggerMessageArgs = buildLoggerMessageArgs({\n            title: title,\n            message: message\n          });\n          _context2.t0 = level;\n          _context2.next = _context2.t0 === LEVELS.debug ? 10 : _context2.t0 === LEVELS.info ? 12 : _context2.t0 === LEVELS.warn ? 14 : _context2.t0 === LEVELS.error ? 16 : 18;\n          break;\n        case 10:\n          (_console2 = console).debug.apply(_console2, _toConsumableArray(loggerMessageArgs));\n          return _context2.abrupt(\"break\", 19);\n        case 12:\n          (_console3 = console).info.apply(_console3, _toConsumableArray(loggerMessageArgs));\n          return _context2.abrupt(\"break\", 19);\n        case 14:\n          (_console4 = console).warn.apply(_console4, _toConsumableArray(loggerMessageArgs));\n          return _context2.abrupt(\"break\", 19);\n        case 16:\n          (_console5 = console).error.apply(_console5, _toConsumableArray(loggerMessageArgs));\n          return _context2.abrupt(\"break\", 19);\n        case 18:\n          (_console6 = console).log.apply(_console6, _toConsumableArray(loggerMessageArgs));\n        case 19:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function log(_x4) {\n    return _ref10.apply(this, arguments);\n  };\n}();\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = function (_ref3) {\n  var pkg = _ref3.pkg,\n    subject = _ref3.subject,\n    transition = _ref3.transition,\n    _ref3$level = _ref3.level,\n    level = _ref3$level === void 0 ? LEVELS.warn : _ref3$level,\n    _ref3$message = _ref3.message,\n    message = _ref3$message === void 0 ? \"\" : _ref3$message,\n    _ref3$callback = _ref3.callback,\n    callback = _ref3$callback === void 0 ? null : _ref3$callback;\n  var capitalizeFirstLetter = function capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  var logMessage = function logMessage() {\n    return log({\n      title: \"\".concat(pkg ? pkg + \" \" : \"\", \"Deprecation Notice\"),\n      message: \"\\n      \".concat(subject ? \"\".concat(capitalizeFirstLetter(subject), \" is deprecated and will cease to work in future releases\").concat(pkg ? \" of \" + pkg : \"\", \".\") : \"\").concat(message ? \"\\n\" + message : \"\").concat(transition ? \"\\nYou can learn more (including a guide on common transition paths) here: \".concat(transition) : \"\", \"\\n    \").trim(),\n      level: level\n    });\n  };\n  if (typeof callback === \"function\") {\n    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n      var _args3 = arguments;\n      return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return logMessage();\n          case 2:\n            _context3.next = 4;\n            return callback.apply(void 0, _args3);\n          case 4:\n            return _context3.abrupt(\"return\", _context3.sent);\n          case 5:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, _callee3);\n    }));\n  }\n  return logMessage();\n};\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    var _console7;\n    var error = new Error(\"INVARIANT \".concat(msg));\n    error.stack = error.stack.split(\"\\n\").filter(function (d) {\n      return !/at invariant/.test(d);\n    }).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    (_console7 = console).error.apply(_console7, [\"\\n\\n---\\n\\n\", error, \"\\n\\n\"].concat(rest, [\"\\n\\n---\\n\\n\"]));\n    throw error;\n  }\n}\nvar pipe = function pipe() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nvar mergePipe = function mergePipe() {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return _objectSpread(_objectSpread({}, res), func(v));\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nvar isObject = function isObject(value) {\n  return value && typeof value === \"object\" && !Array.isArray(value);\n};\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nvar mergeDeep = function mergeDeep(target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  var source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return mergeDeep.apply(void 0, [target].concat(sources));\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nvar mergeFlowJSONs = function mergeFlowJSONs(value) {\n  return Array.isArray(value) ? mergeDeep.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;\n};\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nvar filterContracts = function filterContracts(obj) {\n  return obj.contracts ? obj.contracts : {};\n};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar mapContractAliasesToNetworkAddress = function mapContractAliasesToNetworkAddress(network) {\n  return function (contracts) {\n    return Object.entries(contracts).reduce(function (c, _ref) {\n      var _value$aliases2;\n      var _ref12 = _slicedToArray(_ref, 2),\n        key = _ref12[0],\n        value = _ref12[1];\n      var networkContractAlias = value === null || value === void 0 || (_value$aliases2 = value.aliases) === null || _value$aliases2 === void 0 ? void 0 : _value$aliases2[network];\n      if (networkContractAlias) {\n        c[key] = networkContractAlias;\n      }\n      return c;\n    }, {});\n  };\n};\nvar mapDeploymentsToNetworkAddress = function mapDeploymentsToNetworkAddress(network) {\n  return function (_ref2) {\n    var _ref2$deployments2 = _ref2.deployments,\n      deployments = _ref2$deployments2 === void 0 ? {} : _ref2$deployments2,\n      _ref2$accounts2 = _ref2.accounts,\n      accounts = _ref2$accounts2 === void 0 ? {} : _ref2$accounts2;\n    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];\n    if (!networkDeployment) return {};\n    return Object.entries(networkDeployment).reduce(function (c, _ref3) {\n      var _accounts$key2;\n      var _ref13 = _slicedToArray(_ref3, 2),\n        key = _ref13[0],\n        value = _ref13[1];\n      // Resolve account address\n      var accountAddress = (_accounts$key2 = accounts[key]) === null || _accounts$key2 === void 0 ? void 0 : _accounts$key2.address;\n      if (!accountAddress) return c;\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce(function (c, contract) {\n        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));\n      }, {});\n    }, {});\n  };\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar getContracts = function getContracts(jsons, network) {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nvar isHexidecimal = function isHexidecimal(str) {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nvar hasPrivateKeys = function hasPrivateKeys(flowJSON) {\n  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref4) {\n    var _ref14 = _slicedToArray(_ref4, 2),\n      key = _ref14[0],\n      value = _ref14[1];\n    if (hasPrivateKey) return true;\n    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty(\"key\")) && isHexidecimal(value === null || value === void 0 ? void 0 : value.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nvar anyHasPrivateKeys = function anyHasPrivateKeys(value) {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nvar cleanNetwork = function cleanNetwork(network) {\n  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === \"local\" ? \"emulator\" : network === null || network === void 0 ? void 0 : network.toLowerCase();\n};\nvar NAME = \"config\";\nvar PUT = \"PUT_CONFIG\";\nvar GET = \"GET_CONFIG\";\nvar GET_ALL = \"GET_ALL_CONFIG\";\nvar UPDATE = \"UPDATE_CONFIG\";\nvar DELETE = \"DELETE_CONFIG\";\nvar CLEAR = \"CLEAR_CONFIG\";\nvar WHERE = \"WHERE_CONFIG\";\nvar UPDATED = \"CONFIG/UPDATED\";\nvar identity = function identity(v) {\n  return v;\n};\nvar HANDLERS = (_HANDLERS = {}, _defineProperty(_HANDLERS, PUT, function (ctx, _letter, _ref) {\n  var key = _ref.key,\n    value = _ref.value;\n  if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n  ctx.put(key, value);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, GET, function (ctx, letter, _ref2) {\n  var key = _ref2.key,\n    fallback = _ref2.fallback;\n  if (key == null) throw new Error(\"Missing 'key' for config/get\");\n  letter.reply(ctx.get(key, fallback));\n}), _defineProperty(_HANDLERS, GET_ALL, function (ctx, letter) {\n  letter.reply(_objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, UPDATE, function (ctx, letter, _ref3) {\n  var key = _ref3.key,\n    fn = _ref3.fn;\n  if (key == null) throw new Error(\"Missing 'key' for config/update\");\n  ctx.update(key, fn || identity);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, DELETE, function (ctx, letter, _ref4) {\n  var key = _ref4.key;\n  if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n  ctx.delete(key);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, CLEAR, function (ctx, letter) {\n  var keys = Object.keys(ctx.all());\n  for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n    var key = _keys2[_i2];\n    ctx.delete(key);\n  }\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, WHERE, function (ctx, letter, _ref5) {\n  var pattern = _ref5.pattern;\n  if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n  letter.reply(ctx.where(pattern));\n}), _defineProperty(_HANDLERS, SUBSCRIBE, function (ctx, letter) {\n  ctx.subscribe(letter.from);\n  ctx.send(letter.from, UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {\n  ctx.unsubscribe(letter.from);\n}), _HANDLERS);\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {\n    key: key,\n    value: value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {\n    key: key,\n    fallback: fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction first() {\n  return _first.apply(this, arguments);\n}\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction _first() {\n  _first = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n    var wants,\n      fallback,\n      _wants2,\n      head,\n      rest,\n      ret,\n      _args7 = arguments;\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          wants = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : [];\n          fallback = _args7.length > 1 ? _args7[1] : undefined;\n          if (wants.length) {\n            _context7.next = 4;\n            break;\n          }\n          return _context7.abrupt(\"return\", fallback);\n        case 4:\n          _wants2 = _toArray(wants), head = _wants2[0], rest = _wants2.slice(1);\n          _context7.next = 7;\n          return get(head);\n        case 7:\n          ret = _context7.sent;\n          if (!(ret == null)) {\n            _context7.next = 10;\n            break;\n          }\n          return _context7.abrupt(\"return\", first(rest, fallback));\n        case 10:\n          return _context7.abrupt(\"return\", ret);\n        case 11:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _first.apply(this, arguments);\n}\nfunction all() {\n  return send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  send(NAME, UPDATE, {\n    key: key,\n    fn: fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {\n    key: key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {\n    pattern: pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, function () {\n    return spawn(HANDLERS, NAME);\n  }, callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nfunction load(_x5) {\n  return _load.apply(this, arguments);\n} // eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction _load() {\n  _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(data) {\n    var network, cleanedNetwork, flowJSON, isEmulator, _i4, _Object$entries2, _Object$entries2$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;\n    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n      while (1) switch (_context8.prev = _context8.next) {\n        case 0:\n          _context8.next = 2;\n          return get(\"flow.network\");\n        case 2:\n          network = _context8.sent;\n          cleanedNetwork = cleanNetwork(network);\n          flowJSON = data.flowJSON;\n          invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n          invariant(cleanedNetwork, \"Flow Network Required -- In order for FCL to load your contracts please define \\\"flow.network\\\" to \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl\");\n          if (!anyHasPrivateKeys(flowJSON)) {\n            _context8.next = 12;\n            break;\n          }\n          isEmulator = cleanedNetwork === \"emulator\";\n          log({\n            title: \"Private Keys Detected\",\n            message: \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\",\n            level: isEmulator ? LEVELS.warn : LEVELS.error\n          });\n          if (isEmulator) {\n            _context8.next = 12;\n            break;\n          }\n          return _context8.abrupt(\"return\");\n        case 12:\n          _i4 = 0, _Object$entries2 = Object.entries(getContracts(flowJSON, cleanedNetwork));\n        case 13:\n          if (!(_i4 < _Object$entries2.length)) {\n            _context8.next = 28;\n            break;\n          }\n          _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2), key = _Object$entries2$_i[0], value = _Object$entries2$_i[1];\n          contractConfigKey = \"0x\".concat(key);\n          _context8.next = 18;\n          return get(contractConfigKey);\n        case 18:\n          existingContractConfigKey = _context8.sent;\n          if (existingContractConfigKey && existingContractConfigKey !== value) {\n            log({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS.warn\n            });\n          } else {\n            put(contractConfigKey, value);\n          }\n          systemContractConfigKey = \"system.contracts.\".concat(key);\n          _context8.next = 23;\n          return get(systemContractConfigKey);\n        case 23:\n          systemExistingContractConfigKeyValue = _context8.sent;\n          if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n            log({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS.warn\n            });\n          } else {\n            put(systemContractConfigKey, value);\n          }\n        case 25:\n          _i4++;\n          _context8.next = 13;\n          break;\n        case 28:\n        case \"end\":\n          return _context8.stop();\n      }\n    }, _callee8);\n  }));\n  return _load.apply(this, arguments);\n}\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(function (d) {\n      return put(d, values[d]);\n    });\n  }\n  return {\n    put: put,\n    get: get,\n    all: all,\n    first: first,\n    update: update,\n    delete: _delete,\n    where: where,\n    subscribe: subscribe,\n    overload: overload,\n    load: load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nvar noop = function noop(v) {\n  return v;\n};\nfunction overload() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref15 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(resolve, reject) {\n      var oldConfig, result;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return all();\n          case 2:\n            oldConfig = _context4.sent;\n            _context4.prev = 3;\n            config(opts);\n            _context4.t0 = callback;\n            _context4.next = 8;\n            return all();\n          case 8:\n            _context4.t1 = _context4.sent;\n            _context4.next = 11;\n            return (0, _context4.t0)(_context4.t1);\n          case 11:\n            result = _context4.sent;\n            _context4.next = 14;\n            return resetConfig(oldConfig);\n          case 14:\n            resolve(result);\n            _context4.next = 22;\n            break;\n          case 17:\n            _context4.prev = 17;\n            _context4.t2 = _context4[\"catch\"](3);\n            _context4.next = 21;\n            return resetConfig(oldConfig);\n          case 21:\n            reject(_context4.t2);\n          case 22:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4, null, [[3, 17]]);\n    }));\n    return function (_x6, _x7) {\n      return _ref15.apply(this, arguments);\n    };\n  }());\n}\nexport { clearConfig, config };","map":{"version":3,"names":["invariant$1","fact","msg","_console","error","Error","concat","stack","split","filter","d","test","join","_len","arguments","length","rest","Array","_key","console","apply","LEVELS","Object","freeze","debug","info","log","warn","buildLoggerMessageArgs","_ref","title","message","replace","trim","_ref10","_asyncToGenerator","_regeneratorRuntime","mark","_callee2","_ref2","_console2","_console3","_console4","_console5","_console6","level","_ref2$always","always","configLoggerLevel","loggerMessageArgs","wrap","_callee2$","_context2","prev","next","config$1","get","sent","abrupt","t0","_toConsumableArray","stop","_x4","deprecate","_ref3","pkg","subject","transition","_ref3$level","_ref3$message","_ref3$callback","callback","capitalizeFirstLetter","string","charAt","toUpperCase","slice","logMessage","invariant","_console7","pipe","funcs","v","reduce","res","func","mergePipe","_len2","_key2","_objectSpread","isObject","value","isArray","mergeDeep","target","_len3","sources","_key3","source","shift","key","assign","_defineProperty","mergeFlowJSONs","filterContracts","obj","contracts","mapContractAliasesToNetworkAddress","network","entries","c","_value$aliases2","_ref12","_slicedToArray","networkContractAlias","aliases","mapDeploymentsToNetworkAddress","_ref2$deployments2","deployments","_ref2$accounts2","accounts","networkDeployment","_accounts$key2","_ref13","accountAddress","address","contract","getContracts","jsons","isHexidecimal","str","hasPrivateKeys","flowJSON","hasPrivateKey","_ref4","_ref14","hasOwnProperty","anyHasPrivateKeys","some","cleanNetwork","toLowerCase","NAME","PUT","GET","GET_ALL","UPDATE","DELETE","CLEAR","WHERE","UPDATED","identity","HANDLERS","_HANDLERS","ctx","_letter","put","broadcast","all","letter","fallback","reply","fn","update","delete","keys","_i2","_keys2","_ref5","pattern","where","SUBSCRIBE","subscribe","from","send","UNSUBSCRIBE","unsubscribe","spawn","config","expectReply","timeout","first","_first","_callee7","wants","_wants2","head","ret","_args7","_callee7$","_context7","undefined","_toArray","_delete","subscriber","clearConfig","resetConfig","oldConfig","then","load","_x5","_load","_callee8","data","cleanedNetwork","isEmulator","_i4","_Object$entries2","_Object$entries2$_i","contractConfigKey","existingContractConfigKey","systemContractConfigKey","systemExistingContractConfigKeyValue","_callee8$","_context8","Boolean","values","map","overload","noop","opts","Promise","_ref15","_callee4","resolve","reject","result","_callee4$","_context4","t1","t2","_x6","_x7"],"sources":["/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-invariant/src/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-logger/src/util-logger.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/config/utils/utils.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/config/src/config.js"],"sourcesContent":["/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nexport function invariant(fact, msg, ...rest) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`)\n    error.stack = error.stack\n      .split(\"\\n\")\n      .filter(d => !/at invariant/.test(d))\n      .join(\"\\n\")\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\")\n    throw error\n  }\n}\n","import {config} from \"@onflow/config\"\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nexport const LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1,\n})\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = ({title, message}) => {\n  return [\n    `\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `\n      .replace(/\\n[^\\S\\r\\n]+/g, \"\\n\")\n      .trim(),\n    ,\n    \"font-weight:bold;font-family:monospace;\",\n  ]\n}\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nexport const log = async ({title, message, level, always = false}) => {\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn)\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return\n\n  const loggerMessageArgs = buildLoggerMessageArgs({title, message})\n\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs)\n      break\n    case LEVELS.info:\n      console.info(...loggerMessageArgs)\n      break\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs)\n      break\n    case LEVELS.error:\n      console.error(...loggerMessageArgs)\n      break\n    default:\n      console.log(...loggerMessageArgs)\n  }\n}\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = ({\n  pkg,\n  subject,\n  transition,\n  level = LEVELS.warn,\n  message = \"\",\n  callback = null,\n}) => {\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1)\n  }\n\n  const logMessage = () =>\n    log({\n      title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n      message: `\n      ${\n        subject\n          ? `${capitalizeFirstLetter(\n              subject\n            )} is deprecated and will cease to work in future releases${\n              pkg ? \" of \" + pkg : \"\"\n            }.`\n          : \"\"\n      }${message ? \"\\n\" + message : \"\"}${\n        transition\n          ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}`\n          : \"\"\n      }\n    `.trim(),\n      level,\n    })\n\n  if (typeof callback === \"function\") {\n    return async (...args) => {\n      await logMessage()\n      return await callback(...args)\n    }\n  }\n  return logMessage()\n}\n","const pipe =\n  (...funcs) =>\n  v => {\n    return funcs.reduce((res, func) => {\n      return func(res)\n    }, v)\n  }\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nconst mergePipe =\n  (...funcs) =>\n  v => {\n    return funcs.reduce((res, func) => {\n      return {...res, ...func(v)}\n    }, {})\n  }\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nconst isObject = value =>\n  value && typeof value === \"object\" && !Array.isArray(value)\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nconst mergeDeep = (target, ...sources) => {\n  if (!sources.length) return target\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {[key]: {}})\n        mergeDeep(target[key], source[key])\n      } else {\n        Object.assign(target, {[key]: source[key]})\n      }\n    }\n  }\n\n  return mergeDeep(target, ...sources)\n}\n\n/**\n * @description Support if/then/else behavior in a function way.\n * @param {function(object): boolean} testFn - Function to test\n * @param {function(object): *} posCond - Function to run if testFn is true\n * @param {function(object): *} negCond - Function to run it testFn is false\n * @returns {function(*): *} - Function that returns the result of posCond or negCond\n */\nexport const ifElse = (testFn, posCond, negCond) => obj =>\n  testFn(obj) ? posCond(obj) : negCond(obj)\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nconst mergeFlowJSONs = value =>\n  Array.isArray(value) ? mergeDeep({}, ...value) : value\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nconst filterContracts = obj => (obj.contracts ? obj.contracts : {})\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nconst mapContractAliasesToNetworkAddress = network => contracts => {\n  return Object.entries(contracts).reduce((c, [key, value]) => {\n    const networkContractAlias = value?.aliases?.[network]\n    if (networkContractAlias) {\n      c[key] = networkContractAlias\n    }\n\n    return c\n  }, {})\n}\n\nconst mapDeploymentsToNetworkAddress =\n  network =>\n  ({deployments = {}, accounts = {}}) => {\n    const networkDeployment = deployments?.[network]\n    if (!networkDeployment) return {}\n\n    return Object.entries(networkDeployment).reduce((c, [key, value]) => {\n      // Resolve account address\n      const accountAddress = accounts[key]?.address\n      if (!accountAddress) return c\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce((c, contract) => {\n        return {...c, [contract]: accountAddress}\n      }, {})\n    }, {})\n  }\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nexport const getContracts = (jsons, network) => {\n  return pipe(\n    mergeFlowJSONs,\n    mergePipe(\n      mapDeploymentsToNetworkAddress(network),\n      pipe(filterContracts, mapContractAliasesToNetworkAddress(network))\n    )\n  )(jsons)\n}\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nconst isHexidecimal = str => {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false\n  return /^[0-9A-Fa-f]+$/.test(str)\n}\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nconst hasPrivateKeys = flowJSON => {\n  return Object.entries(flowJSON?.accounts).reduce(\n    (hasPrivateKey, [key, value]) => {\n      if (hasPrivateKey) return true\n      return value?.hasOwnProperty(\"key\") && isHexidecimal(value?.key)\n    },\n    false\n  )\n}\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nexport const anyHasPrivateKeys = value => {\n  if (isObject(value)) return hasPrivateKeys(value)\n  return value.some(hasPrivateKeys)\n}\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nexport const cleanNetwork = network =>\n  network?.toLowerCase() === \"local\" ? \"emulator\" : network?.toLowerCase()\n","import {\n  spawn,\n  send,\n  subscriber,\n  SUBSCRIBE,\n  UNSUBSCRIBE,\n} from \"@onflow/util-actor\"\nimport * as logger from \"@onflow/util-logger\"\nimport {invariant} from \"@onflow/util-invariant\"\nimport {getContracts, cleanNetwork, anyHasPrivateKeys} from \"../utils/utils\"\n\nconst NAME = \"config\"\nconst PUT = \"PUT_CONFIG\"\nconst GET = \"GET_CONFIG\"\nconst GET_ALL = \"GET_ALL_CONFIG\"\nconst UPDATE = \"UPDATE_CONFIG\"\nconst DELETE = \"DELETE_CONFIG\"\nconst CLEAR = \"CLEAR_CONFIG\"\nconst WHERE = \"WHERE_CONFIG\"\nconst UPDATED = \"CONFIG/UPDATED\"\n\nconst identity = v => v\n\nconst HANDLERS = {\n  [PUT]: (ctx, _letter, {key, value}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/put.\")\n    ctx.put(key, value)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [GET]: (ctx, letter, {key, fallback}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/get\")\n    letter.reply(ctx.get(key, fallback))\n  },\n  [GET_ALL]: (ctx, letter) => {\n    letter.reply({...ctx.all()})\n  },\n  [UPDATE]: (ctx, letter, {key, fn}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/update\")\n    ctx.update(key, fn || identity)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [DELETE]: (ctx, letter, {key}) => {\n    if (key == null) throw new Error(\"Missing 'key' for config/delete\")\n    ctx.delete(key)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [CLEAR]: (ctx, letter) => {\n    let keys = Object.keys(ctx.all())\n    for (let key of keys) ctx.delete(key)\n    ctx.broadcast(UPDATED, {...ctx.all()})\n  },\n  [WHERE]: (ctx, letter, {pattern}) => {\n    if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\")\n    letter.reply(ctx.where(pattern))\n  },\n  [SUBSCRIBE]: (ctx, letter) => {\n    ctx.subscribe(letter.from)\n    ctx.send(letter.from, UPDATED, {...ctx.all()})\n  },\n  [UNSUBSCRIBE]: (ctx, letter) => {\n    ctx.unsubscribe(letter.from)\n  },\n}\n\nspawn(HANDLERS, NAME)\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  send(NAME, PUT, {key, value})\n  return config()\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return send(NAME, GET, {key, fallback}, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nasync function first(wants = [], fallback) {\n  if (!wants.length) return fallback\n  const [head, ...rest] = wants\n  const ret = await get(head)\n  if (ret == null) return first(rest, fallback)\n  return ret\n}\n\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction all() {\n  return send(NAME, GET_ALL, null, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key, fn = identity) {\n  send(NAME, UPDATE, {key, fn})\n  return config()\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  send(NAME, DELETE, {key})\n  return config()\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return send(NAME, WHERE, {pattern}, {expectReply: true, timeout: 10})\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, () => spawn(HANDLERS, NAME), callback)\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nexport function clearConfig() {\n  return send(NAME, CLEAR)\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig))\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nasync function load(data) {\n  const network = await get(\"flow.network\")\n  const cleanedNetwork = cleanNetwork(network)\n  const {flowJSON} = data\n\n  invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\")\n\n  invariant(\n    cleanedNetwork,\n    `Flow Network Required -- In order for FCL to load your contracts please define \"flow.network\" to \"emulator\", \"local\", \"testnet\", or \"mainnet\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl`\n  )\n\n  if (anyHasPrivateKeys(flowJSON)) {\n    const isEmulator = cleanedNetwork === \"emulator\"\n\n    logger.log({\n      title: \"Private Keys Detected\",\n      message: `Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security`,\n      level: isEmulator ? logger.LEVELS.warn : logger.LEVELS.error,\n    })\n\n    if (!isEmulator) return\n  }\n\n  for (const [key, value] of Object.entries(\n    getContracts(flowJSON, cleanedNetwork)\n  )) {\n    const contractConfigKey = `0x${key}`\n    const existingContractConfigKey = await get(contractConfigKey)\n    if (existingContractConfigKey && existingContractConfigKey !== value) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: logger.LEVELS.warn,\n      })\n    } else {\n      put(contractConfigKey, value)\n    }\n\n    const systemContractConfigKey = `system.contracts.${key}`\n    const systemExistingContractConfigKeyValue = await get(\n      systemContractConfigKey\n    )\n    if (\n      systemExistingContractConfigKeyValue &&\n      systemExistingContractConfigKeyValue !== value\n    ) {\n      logger.log({\n        title: \"Contract Placeholder Conflict Detected\",\n        message: `A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.`,\n        level: logger.LEVELS.warn,\n      })\n    } else {\n      put(systemContractConfigKey, value)\n    }\n  }\n}\n\n// eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(d => put(d, values[d]))\n  }\n\n  return {\n    put,\n    get,\n    all,\n    first,\n    update,\n    delete: _delete,\n    where,\n    subscribe,\n    overload,\n    load,\n  }\n}\n\nconfig.put = put\nconfig.get = get\nconfig.all = all\nconfig.first = first\nconfig.update = update\nconfig.delete = _delete\nconfig.where = where\nconfig.subscribe = subscribe\nconfig.overload = overload\nconfig.load = load\n\nexport {config}\n\nconst noop = v => v\nfunction overload(opts = {}, callback = noop) {\n  return new Promise(async (resolve, reject) => {\n    const oldConfig = await all()\n    try {\n      config(opts)\n      var result = await callback(await all())\n      await resetConfig(oldConfig)\n      resolve(result)\n    } catch (error) {\n      await resetConfig(oldConfig)\n      reject(error)\n    }\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}