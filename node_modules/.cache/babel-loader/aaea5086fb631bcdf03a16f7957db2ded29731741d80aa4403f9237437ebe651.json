{"ast":null,"code":"import queueMicrotask from 'queue-microtask';\nconst mailbox = () => {\n  const queue = [];\n  var next;\n  return {\n    async deliver(msg) {\n      queue.push(msg);\n      if (next) {\n        next(queue.shift());\n        next = undefined;\n      }\n    },\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nconst INIT = \"INIT\";\nconst SUBSCRIBE = \"SUBSCRIBE\";\nconst UNSUBSCRIBE = \"UNSUBSCRIBE\";\nconst UPDATED = \"UPDATED\";\nconst SNAPSHOT = \"SNAPSHOT\";\nconst EXIT = \"EXIT\";\nconst TERMINATE = \"TERMINATE\";\nconst root = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0b0;\nconst DEFAULT_TIMEOUT = 5000;\nconst send = function (addr, tag, data) {\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false;\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(() => reject(new Error(`Timeout: ${timeout}ms passed without a response.`)), timeout);\n    }\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nconst kill = addr => {\n  delete root.FCL_REGISTRY[addr];\n};\nconst fromHandlers = function () {\n  let handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx);\n    __loop: while (1) {\n      const letter = await ctx.receive();\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {});\n          }\n          break __loop;\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {});\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error);\n      } finally {\n        continue __loop;\n      }\n    }\n  };\n};\nconst spawn = function (fn) {\n  let addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: function (to, tag, data) {\n      let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return send(to, tag, data, opts);\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts);\n    },\n    broadcast: function (tag, data) {\n      let opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts);\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: (key, fn) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key) ? {\n          ...acc,\n          [key]: root.FCL_REGISTRY[addr].kvs[key]\n        } : acc;\n      }, {});\n    },\n    merge: function () {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(key => root.FCL_REGISTRY[addr].kvs[key] = data[key]);\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error;\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED);\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask(async () => {\n    await fn(ctx);\n    kill(addr);\n  });\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  const EXIT = \"@EXIT\";\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE);\n    while (1) {\n      const letter = await ctx.receive();\n      const error = root.FCL_REGISTRY[address].error;\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      if (error) {\n        callback(null, error);\n        ctx.send(address, UNSUBSCRIBE);\n        return;\n      }\n      callback(letter.data, null);\n    }\n  });\n  return () => send(self, EXIT);\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nfunction snapshoter(address, spawnFn) {\n  spawnFn(address);\n  return send(address, SNAPSHOT, null, {\n    expectReply: true,\n    timeout: 0\n  });\n}\nexport { EXIT, INIT, SNAPSHOT, SUBSCRIBE, TERMINATE, UNSUBSCRIBE, UPDATED, kill, send, snapshoter, spawn, subscriber };","map":{"version":3,"names":["mailbox","queue","next","deliver","msg","push","shift","undefined","receive","Promise","innerReceive","resolve","INIT","SUBSCRIBE","UNSUBSCRIBE","UPDATED","SNAPSHOT","EXIT","TERMINATE","root","self","global","window","FCL_REGISTRY","pid","DEFAULT_TIMEOUT","send","addr","tag","data","opts","arguments","length","reply","reject","expectReply","timeout","setTimeout","Error","payload","to","from","error","console","kill","fromHandlers","handlers","ctx","__loop","letter","spawn","fn","subs","Set","kvs","sendSelf","broadcast","subscribe","sub","add","unsubscribe","delete","subscriberCount","size","hasSubs","put","key","value","get","fallback","update","keys","Object","all","where","pattern","reduce","acc","test","merge","forEach","fatalError","queueMicrotask","subscriber","address","spawnFn","callback","snapshoter"],"sources":["/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-actor/src/mailbox/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-actor/src/index.js"],"sourcesContent":["export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","import {mailbox as createMailbox} from \"./mailbox\"\nimport queueMicrotask from \"queue-microtask\"\n\nexport const INIT = \"INIT\"\nexport const SUBSCRIBE = \"SUBSCRIBE\"\nexport const UNSUBSCRIBE = \"UNSUBSCRIBE\"\nexport const UPDATED = \"UPDATED\"\nexport const SNAPSHOT = \"SNAPSHOT\"\nexport const EXIT = \"EXIT\"\nexport const TERMINATE = \"TERMINATE\"\n\nconst root =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  (typeof window === \"object\" && window.window === window && window)\n\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY\nvar pid = 0b0\n\nconst DEFAULT_TIMEOUT = 5000\nconst DEFAULT_TAG = \"---\"\nexport const send = (addr, tag, data, opts = {}) =>\n  new Promise((reply, reject) => {\n    const expectReply = opts.expectReply || false\n    const timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT\n\n    if (expectReply && timeout) {\n      setTimeout(\n        () =>\n          reject(new Error(`Timeout: ${timeout}ms passed without a response.`)),\n        timeout\n      )\n    }\n\n    const payload = {\n      to: addr,\n      from: opts.from,\n      tag,\n      data,\n      timeout,\n      reply,\n      reject,\n    }\n\n    try {\n      root.FCL_REGISTRY[addr] &&\n        root.FCL_REGISTRY[addr].mailbox.deliver(payload)\n      if (!expectReply) reply(true)\n    } catch (error) {\n      console.error(\n        \"FCL.Actor -- Could Not Deliver Message\",\n        payload,\n        root.FCL_REGISTRY[addr],\n        error\n      )\n    }\n  })\n\nexport const kill = addr => {\n  delete root.FCL_REGISTRY[addr]\n}\n\nconst fromHandlers =\n  (handlers = {}) =>\n  async ctx => {\n    if (typeof handlers[INIT] === \"function\") await handlers[INIT](ctx)\n    __loop: while (1) {\n      const letter = await ctx.receive()\n      try {\n        if (letter.tag === EXIT) {\n          if (typeof handlers[TERMINATE] === \"function\") {\n            await handlers[TERMINATE](ctx, letter, letter.data || {})\n          }\n          break __loop\n        }\n        await handlers[letter.tag](ctx, letter, letter.data || {})\n      } catch (error) {\n        console.error(`${ctx.self()} Error`, letter, error)\n      } finally {\n        continue __loop\n      }\n    }\n  }\n\nexport const spawn = (fn, addr = null) => {\n  if (addr == null) addr = ++pid\n  if (root.FCL_REGISTRY[addr] != null) return addr\n\n  root.FCL_REGISTRY[addr] = {\n    addr,\n    mailbox: createMailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null,\n  }\n\n  const ctx = {\n    self: () => addr,\n    receive: () => root.FCL_REGISTRY[addr].mailbox.receive(),\n    send: (to, tag, data, opts = {}) => {\n      opts.from = addr\n      return send(to, tag, data, opts)\n    },\n    sendSelf: (tag, data, opts) => {\n      if (root.FCL_REGISTRY[addr]) send(addr, tag, data, opts)\n    },\n    broadcast: (tag, data, opts = {}) => {\n      opts.from = addr\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, tag, data, opts)\n    },\n    subscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.add(sub),\n    unsubscribe: sub => sub != null && root.FCL_REGISTRY[addr].subs.delete(sub),\n    subscriberCount: () => root.FCL_REGISTRY[addr].subs.size,\n    hasSubs: () => !!root.FCL_REGISTRY[addr].subs.size,\n    put: (key, value) => {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value\n    },\n    get: (key, fallback) => {\n      const value = root.FCL_REGISTRY[addr].kvs[key]\n      return value == null ? fallback : value\n    },\n    delete: key => {\n      delete root.FCL_REGISTRY[addr].kvs[key]\n    },\n    update: (key, fn) => {\n      if (key != null)\n        root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key])\n    },\n    keys: () => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs)\n    },\n    all: () => {\n      return root.FCL_REGISTRY[addr].kvs\n    },\n    where: pattern => {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce((acc, key) => {\n        return pattern.test(key)\n          ? {...acc, [key]: root.FCL_REGISTRY[addr].kvs[key]}\n          : acc\n      }, {})\n    },\n    merge: (data = {}) => {\n      Object.keys(data).forEach(\n        key => (root.FCL_REGISTRY[addr].kvs[key] = data[key])\n      )\n    },\n    fatalError: error => {\n      root.FCL_REGISTRY[addr].error = error\n      for (let to of root.FCL_REGISTRY[addr].subs) send(to, UPDATED)\n    },\n  }\n\n  if (typeof fn === \"object\") fn = fromHandlers(fn)\n\n  queueMicrotask(async () => {\n    await fn(ctx)\n    kill(addr)\n  })\n\n  return addr\n}\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nexport function subscriber(address, spawnFn, callback) {\n  spawnFn(address)\n  const EXIT = \"@EXIT\"\n  const self = spawn(async ctx => {\n    ctx.send(address, SUBSCRIBE)\n    while (1) {\n      const letter = await ctx.receive()\n      const error = root.FCL_REGISTRY[address].error\n      if (letter.tag === EXIT) {\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n      if (error) {\n        callback(null, error)\n        ctx.send(address, UNSUBSCRIBE)\n        return\n      }\n\n      callback(letter.data, null)\n    }\n  })\n  return () => send(self, EXIT)\n}\n\n// Returns a promise that returns a result\n// A SNAPSHOT handler will need to be created to handle the snapshot event\n//\n//  [SNAPSHOT]: (ctx, letter) => {\n//    letter.reply(ctx.all())\n//  }\n//\nexport function snapshoter(address, spawnFn) {\n  spawnFn(address)\n  return send(address, SNAPSHOT, null, {expectReply: true, timeout: 0})\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}