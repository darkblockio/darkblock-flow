{"ast":null,"code":"import _toArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/toArray.js\";\nimport _slicedToArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _defineProperty from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nvar _HANDLERS$, _HANDLERS;\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nvar promise;\nvar queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask.bind(typeof window !== 'undefined' ? window : commonjsGlobal)\n// reuse resolved promise, and allocate it lazily\n: function (cb) {\n  return (promise || (promise = Promise.resolve())).then(cb).catch(function (err) {\n    return setTimeout(function () {\n      throw err;\n    }, 0);\n  });\n};\nvar mailbox = function mailbox() {\n  var queue = [];\n  var next;\n  return {\n    deliver: function deliver(msg) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              queue.push(msg);\n              if (next) {\n                next(queue.shift());\n                next = undefined;\n              }\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }))();\n    },\n    receive: function receive() {\n      return new Promise(function innerReceive(resolve) {\n        var msg = queue.shift();\n        if (msg) return resolve(msg);\n        next = resolve;\n      });\n    }\n  };\n};\nvar INIT = \"INIT\";\nvar SUBSCRIBE = \"SUBSCRIBE\";\nvar UNSUBSCRIBE = \"UNSUBSCRIBE\";\nvar UPDATED$2 = \"UPDATED\";\nvar EXIT = \"EXIT\";\nvar TERMINATE = \"TERMINATE\";\nvar root = typeof self === \"object\" && self.self === self && self || typeof global === \"object\" && global.global === global && global || typeof window === \"object\" && window.window === window && window;\nroot.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;\nvar pid = 0;\nvar DEFAULT_TIMEOUT = 5000;\nvar _send = function send(addr, tag, data) {\n  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return new Promise(function (reply, reject) {\n    var expectReply = opts.expectReply || false;\n    var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;\n    if (expectReply && timeout) {\n      setTimeout(function () {\n        return reject(new Error(\"Timeout: \".concat(timeout, \"ms passed without a response.\")));\n      }, timeout);\n    }\n    var payload = {\n      to: addr,\n      from: opts.from,\n      tag: tag,\n      data: data,\n      timeout: timeout,\n      reply: reply,\n      reject: reject\n    };\n    try {\n      root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);\n      if (!expectReply) reply(true);\n    } catch (error) {\n      console.error(\"FCL.Actor -- Could Not Deliver Message\", payload, root.FCL_REGISTRY[addr], error);\n    }\n  });\n};\nvar kill = function kill(addr) {\n  delete root.FCL_REGISTRY[addr];\n};\nvar fromHandlers = function fromHandlers() {\n  var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return /*#__PURE__*/function () {\n    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(ctx) {\n      var letter;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(typeof handlers[INIT] === \"function\")) {\n              _context2.next = 3;\n              break;\n            }\n            _context2.next = 3;\n            return handlers[INIT](ctx);\n          case 3:\n            if (!1) {\n              _context2.next = 25;\n              break;\n            }\n            _context2.next = 6;\n            return ctx.receive();\n          case 6:\n            letter = _context2.sent;\n            _context2.prev = 7;\n            if (!(letter.tag === EXIT)) {\n              _context2.next = 13;\n              break;\n            }\n            if (!(typeof handlers[TERMINATE] === \"function\")) {\n              _context2.next = 12;\n              break;\n            }\n            _context2.next = 12;\n            return handlers[TERMINATE](ctx, letter, letter.data || {});\n          case 12:\n            return _context2.abrupt(\"break\", 25);\n          case 13:\n            _context2.next = 15;\n            return handlers[letter.tag](ctx, letter, letter.data || {});\n          case 15:\n            _context2.next = 20;\n            break;\n          case 17:\n            _context2.prev = 17;\n            _context2.t0 = _context2[\"catch\"](7);\n            console.error(\"\".concat(ctx.self(), \" Error\"), letter, _context2.t0);\n          case 20:\n            _context2.prev = 20;\n            return _context2.abrupt(\"continue\", 3);\n          case 23:\n            _context2.next = 3;\n            break;\n          case 25:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[7, 17, 20, 23]]);\n    }));\n    return function (_x) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n};\nvar spawn = function spawn(fn) {\n  var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  if (addr == null) addr = ++pid;\n  if (root.FCL_REGISTRY[addr] != null) return addr;\n  root.FCL_REGISTRY[addr] = {\n    addr: addr,\n    mailbox: mailbox(),\n    subs: new Set(),\n    kvs: {},\n    error: null\n  };\n  var ctx = {\n    self: function self() {\n      return addr;\n    },\n    receive: function receive() {\n      return root.FCL_REGISTRY[addr].mailbox.receive();\n    },\n    send: function send(to, tag, data) {\n      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      opts.from = addr;\n      return _send(to, tag, data, opts);\n    },\n    sendSelf: function sendSelf(tag, data, opts) {\n      if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);\n    },\n    broadcast: function broadcast(tag, data) {\n      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      opts.from = addr;\n      var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var to = _step.value;\n          _send(to, tag, data, opts);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    },\n    subscribe: function subscribe(sub) {\n      return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);\n    },\n    unsubscribe: function unsubscribe(sub) {\n      return sub != null && root.FCL_REGISTRY[addr].subs.delete(sub);\n    },\n    subscriberCount: function subscriberCount() {\n      return root.FCL_REGISTRY[addr].subs.size;\n    },\n    hasSubs: function hasSubs() {\n      return !!root.FCL_REGISTRY[addr].subs.size;\n    },\n    put: function put(key, value) {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;\n    },\n    get: function get(key, fallback) {\n      var value = root.FCL_REGISTRY[addr].kvs[key];\n      return value == null ? fallback : value;\n    },\n    delete: function _delete(key) {\n      delete root.FCL_REGISTRY[addr].kvs[key];\n    },\n    update: function update(key, fn) {\n      if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);\n    },\n    keys: function keys() {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs);\n    },\n    all: function all() {\n      return root.FCL_REGISTRY[addr].kvs;\n    },\n    where: function where(pattern) {\n      return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {\n        return pattern.test(key) ? _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;\n      }, {});\n    },\n    merge: function merge() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      Object.keys(data).forEach(function (key) {\n        return root.FCL_REGISTRY[addr].kvs[key] = data[key];\n      });\n    },\n    fatalError: function fatalError(error) {\n      root.FCL_REGISTRY[addr].error = error;\n      var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var to = _step2.value;\n          _send(to, UPDATED$2);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  };\n  if (typeof fn === \"object\") fn = fromHandlers(fn);\n  queueMicrotask_1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _context3.next = 2;\n          return fn(ctx);\n        case 2:\n          kill(addr);\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  })));\n  return addr;\n};\n\n// Returns an unsubscribe function\n// A SUBSCRIBE handler will need to be created to handle the subscription event\n//\n//  [SUBSCRIBE]: (ctx, letter) => {\n//    ctx.subscribe(letter.from)\n//    ctx.send(letter.from, UPDATED, ctx.all())\n//  }\n//\nfunction subscriber(address, spawnFn, callback) {\n  spawnFn(address);\n  var EXIT = \"@EXIT\";\n  var self = spawn( /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(ctx) {\n      var letter, error;\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            ctx.send(address, SUBSCRIBE);\n          case 1:\n            if (!1) {\n              _context4.next = 16;\n              break;\n            }\n            _context4.next = 4;\n            return ctx.receive();\n          case 4:\n            letter = _context4.sent;\n            error = root.FCL_REGISTRY[address].error;\n            if (!(letter.tag === EXIT)) {\n              _context4.next = 9;\n              break;\n            }\n            ctx.send(address, UNSUBSCRIBE);\n            return _context4.abrupt(\"return\");\n          case 9:\n            if (!error) {\n              _context4.next = 13;\n              break;\n            }\n            callback(null, error);\n            ctx.send(address, UNSUBSCRIBE);\n            return _context4.abrupt(\"return\");\n          case 13:\n            callback(letter.data, null);\n            _context4.next = 1;\n            break;\n          case 16:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    return function (_x2) {\n      return _ref8.apply(this, arguments);\n    };\n  }());\n  return function () {\n    return _send(self, EXIT);\n  };\n}\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant$1(fact, msg) {\n  if (!fact) {\n    var _console;\n    var error = new Error(\"INVARIANT \".concat(msg));\n    error.stack = error.stack.split(\"\\n\").filter(function (d) {\n      return !/at invariant/.test(d);\n    }).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    (_console = console).error.apply(_console, [\"\\n\\n---\\n\\n\", error, \"\\n\\n\"].concat(rest, [\"\\n\\n---\\n\\n\"]));\n    throw error;\n  }\n}\nvar pipe$1 = function pipe$1() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nvar mergePipe$1 = function mergePipe$1() {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return _objectSpread(_objectSpread({}, res), func(v));\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nvar isObject$1 = function isObject$1(value) {\n  return value && typeof value === \"object\" && !Array.isArray(value);\n};\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nvar mergeDeep$1 = function mergeDeep$1(target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  var source = sources.shift();\n  if (isObject$1(target) && isObject$1(source)) {\n    for (var key in source) {\n      if (isObject$1(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep$1(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return mergeDeep$1.apply(void 0, [target].concat(sources));\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nvar mergeFlowJSONs$1 = function mergeFlowJSONs$1(value) {\n  return Array.isArray(value) ? mergeDeep$1.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;\n};\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nvar filterContracts$1 = function filterContracts$1(obj) {\n  return obj.contracts ? obj.contracts : {};\n};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar mapContractAliasesToNetworkAddress$1 = function mapContractAliasesToNetworkAddress$1(network) {\n  return function (contracts) {\n    return Object.entries(contracts).reduce(function (c, _ref) {\n      var _value$aliases;\n      var _ref9 = _slicedToArray(_ref, 2),\n        key = _ref9[0],\n        value = _ref9[1];\n      var networkContractAlias = value === null || value === void 0 || (_value$aliases = value.aliases) === null || _value$aliases === void 0 ? void 0 : _value$aliases[network];\n      if (networkContractAlias) {\n        c[key] = networkContractAlias;\n      }\n      return c;\n    }, {});\n  };\n};\nvar mapDeploymentsToNetworkAddress$1 = function mapDeploymentsToNetworkAddress$1(network) {\n  return function (_ref2) {\n    var _ref2$deployments = _ref2.deployments,\n      deployments = _ref2$deployments === void 0 ? {} : _ref2$deployments,\n      _ref2$accounts = _ref2.accounts,\n      accounts = _ref2$accounts === void 0 ? {} : _ref2$accounts;\n    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];\n    if (!networkDeployment) return {};\n    return Object.entries(networkDeployment).reduce(function (c, _ref3) {\n      var _accounts$key;\n      var _ref10 = _slicedToArray(_ref3, 2),\n        key = _ref10[0],\n        value = _ref10[1];\n      // Resolve account address\n      var accountAddress = (_accounts$key = accounts[key]) === null || _accounts$key === void 0 ? void 0 : _accounts$key.address;\n      if (!accountAddress) return c;\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce(function (c, contract) {\n        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));\n      }, {});\n    }, {});\n  };\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar getContracts$1 = function getContracts$1(jsons, network) {\n  return pipe$1(mergeFlowJSONs$1, mergePipe$1(mapDeploymentsToNetworkAddress$1(network), pipe$1(filterContracts$1, mapContractAliasesToNetworkAddress$1(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nvar isHexidecimal$1 = function isHexidecimal$1(str) {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nvar hasPrivateKeys$1 = function hasPrivateKeys$1(flowJSON) {\n  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref4) {\n    var _ref11 = _slicedToArray(_ref4, 2),\n      key = _ref11[0],\n      value = _ref11[1];\n    if (hasPrivateKey) return true;\n    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty(\"key\")) && isHexidecimal$1(value === null || value === void 0 ? void 0 : value.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nvar anyHasPrivateKeys$1 = function anyHasPrivateKeys$1(value) {\n  if (isObject$1(value)) return hasPrivateKeys$1(value);\n  return value.some(hasPrivateKeys$1);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nvar cleanNetwork$1 = function cleanNetwork$1(network) {\n  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === \"local\" ? \"emulator\" : network === null || network === void 0 ? void 0 : network.toLowerCase();\n};\nvar NAME$1 = \"config\";\nvar PUT$1 = \"PUT_CONFIG\";\nvar GET$1 = \"GET_CONFIG\";\nvar GET_ALL$1 = \"GET_ALL_CONFIG\";\nvar UPDATE$1 = \"UPDATE_CONFIG\";\nvar DELETE$1 = \"DELETE_CONFIG\";\nvar CLEAR$1 = \"CLEAR_CONFIG\";\nvar WHERE$1 = \"WHERE_CONFIG\";\nvar UPDATED$1 = \"CONFIG/UPDATED\";\nvar identity$1 = function identity$1(v) {\n  return v;\n};\nvar HANDLERS$1 = (_HANDLERS$ = {}, _defineProperty(_HANDLERS$, PUT$1, function (ctx, _letter, _ref) {\n  var key = _ref.key,\n    value = _ref.value;\n  if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n  ctx.put(key, value);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, GET$1, function (ctx, letter, _ref2) {\n  var key = _ref2.key,\n    fallback = _ref2.fallback;\n  if (key == null) throw new Error(\"Missing 'key' for config/get\");\n  letter.reply(ctx.get(key, fallback));\n}), _defineProperty(_HANDLERS$, GET_ALL$1, function (ctx, letter) {\n  letter.reply(_objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, UPDATE$1, function (ctx, letter, _ref3) {\n  var key = _ref3.key,\n    fn = _ref3.fn;\n  if (key == null) throw new Error(\"Missing 'key' for config/update\");\n  ctx.update(key, fn || identity$1);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, DELETE$1, function (ctx, letter, _ref4) {\n  var key = _ref4.key;\n  if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n  ctx.delete(key);\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, CLEAR$1, function (ctx, letter) {\n  var keys = Object.keys(ctx.all());\n  for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {\n    var key = _keys[_i];\n    ctx.delete(key);\n  }\n  ctx.broadcast(UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, WHERE$1, function (ctx, letter, _ref5) {\n  var pattern = _ref5.pattern;\n  if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n  letter.reply(ctx.where(pattern));\n}), _defineProperty(_HANDLERS$, SUBSCRIBE, function (ctx, letter) {\n  ctx.subscribe(letter.from);\n  ctx.send(letter.from, UPDATED$1, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS$, UNSUBSCRIBE, function (ctx, letter) {\n  ctx.unsubscribe(letter.from);\n}), _HANDLERS$);\nspawn(HANDLERS$1, NAME$1);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put$1(key, value) {\n  _send(NAME$1, PUT$1, {\n    key: key,\n    value: value\n  });\n  return config$1();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get$1(key, fallback) {\n  return _send(NAME$1, GET$1, {\n    key: key,\n    fallback: fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction first$1() {\n  return _first$.apply(this, arguments);\n}\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction _first$() {\n  _first$ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n    var wants,\n      fallback,\n      _wants,\n      head,\n      rest,\n      ret,\n      _args11 = arguments;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          wants = _args11.length > 0 && _args11[0] !== undefined ? _args11[0] : [];\n          fallback = _args11.length > 1 ? _args11[1] : undefined;\n          if (wants.length) {\n            _context11.next = 4;\n            break;\n          }\n          return _context11.abrupt(\"return\", fallback);\n        case 4:\n          _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);\n          _context11.next = 7;\n          return get$1(head);\n        case 7:\n          ret = _context11.sent;\n          if (!(ret == null)) {\n            _context11.next = 10;\n            break;\n          }\n          return _context11.abrupt(\"return\", first$1(rest, fallback));\n        case 10:\n          return _context11.abrupt(\"return\", ret);\n        case 11:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11);\n  }));\n  return _first$.apply(this, arguments);\n}\nfunction all$1() {\n  return _send(NAME$1, GET_ALL$1, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update$1(key) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1;\n  _send(NAME$1, UPDATE$1, {\n    key: key,\n    fn: fn\n  });\n  return config$1();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete$1(key) {\n  _send(NAME$1, DELETE$1, {\n    key: key\n  });\n  return config$1();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where$1(pattern) {\n  return _send(NAME$1, WHERE$1, {\n    pattern: pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe$1(callback) {\n  return subscriber(NAME$1, function () {\n    return spawn(HANDLERS$1, NAME$1);\n  }, callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig$1() {\n  return _send(NAME$1, CLEAR$1);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig$1(oldConfig) {\n  return clearConfig$1().then(config$1(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nfunction load$1(_x3) {\n  return _load$.apply(this, arguments);\n} // eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction _load$() {\n  _load$ = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(data) {\n    var network, cleanedNetwork, flowJSON, isEmulator, _i3, _Object$entries, _Object$entries$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;\n    return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n      while (1) switch (_context12.prev = _context12.next) {\n        case 0:\n          _context12.next = 2;\n          return get$1(\"flow.network\");\n        case 2:\n          network = _context12.sent;\n          cleanedNetwork = cleanNetwork$1(network);\n          flowJSON = data.flowJSON;\n          invariant$1(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n          invariant$1(cleanedNetwork, \"Flow Network Required -- In order for FCL to load your contracts please define \\\"flow.network\\\" to \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl\");\n          if (!anyHasPrivateKeys$1(flowJSON)) {\n            _context12.next = 12;\n            break;\n          }\n          isEmulator = cleanedNetwork === \"emulator\";\n          log$1({\n            title: \"Private Keys Detected\",\n            message: \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\",\n            level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n          });\n          if (isEmulator) {\n            _context12.next = 12;\n            break;\n          }\n          return _context12.abrupt(\"return\");\n        case 12:\n          _i3 = 0, _Object$entries = Object.entries(getContracts$1(flowJSON, cleanedNetwork));\n        case 13:\n          if (!(_i3 < _Object$entries.length)) {\n            _context12.next = 28;\n            break;\n          }\n          _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];\n          contractConfigKey = \"0x\".concat(key);\n          _context12.next = 18;\n          return get$1(contractConfigKey);\n        case 18:\n          existingContractConfigKey = _context12.sent;\n          if (existingContractConfigKey && existingContractConfigKey !== value) {\n            log$1({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS$1.warn\n            });\n          } else {\n            put$1(contractConfigKey, value);\n          }\n          systemContractConfigKey = \"system.contracts.\".concat(key);\n          _context12.next = 23;\n          return get$1(systemContractConfigKey);\n        case 23:\n          systemExistingContractConfigKeyValue = _context12.sent;\n          if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n            log$1({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS$1.warn\n            });\n          } else {\n            put$1(systemContractConfigKey, value);\n          }\n        case 25:\n          _i3++;\n          _context12.next = 13;\n          break;\n        case 28:\n        case \"end\":\n          return _context12.stop();\n      }\n    }, _callee12);\n  }));\n  return _load$.apply(this, arguments);\n}\nfunction config$1(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(function (d) {\n      return put$1(d, values[d]);\n    });\n  }\n  return {\n    put: put$1,\n    get: get$1,\n    all: all$1,\n    first: first$1,\n    update: update$1,\n    delete: _delete$1,\n    where: where$1,\n    subscribe: subscribe$1,\n    overload: overload$1,\n    load: load$1\n  };\n}\nconfig$1.put = put$1;\nconfig$1.get = get$1;\nconfig$1.all = all$1;\nconfig$1.first = first$1;\nconfig$1.update = update$1;\nconfig$1.delete = _delete$1;\nconfig$1.where = where$1;\nconfig$1.subscribe = subscribe$1;\nconfig$1.overload = overload$1;\nconfig$1.load = load$1;\nvar noop$1 = function noop$1(v) {\n  return v;\n};\nfunction overload$1() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(resolve, reject) {\n      var oldConfig, result;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return all$1();\n          case 2:\n            oldConfig = _context5.sent;\n            _context5.prev = 3;\n            config$1(opts);\n            _context5.t0 = callback;\n            _context5.next = 8;\n            return all$1();\n          case 8:\n            _context5.t1 = _context5.sent;\n            _context5.next = 11;\n            return (0, _context5.t0)(_context5.t1);\n          case 11:\n            result = _context5.sent;\n            _context5.next = 14;\n            return resetConfig$1(oldConfig);\n          case 14:\n            resolve(result);\n            _context5.next = 22;\n            break;\n          case 17:\n            _context5.prev = 17;\n            _context5.t2 = _context5[\"catch\"](3);\n            _context5.next = 21;\n            return resetConfig$1(oldConfig);\n          case 21:\n            reject(_context5.t2);\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5, null, [[3, 17]]);\n    }));\n    return function (_x4, _x5) {\n      return _ref12.apply(this, arguments);\n    };\n  }());\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nvar LEVELS$1 = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nvar buildLoggerMessageArgs$1 = function buildLoggerMessageArgs$1(_ref) {\n  var title = _ref.title,\n    message = _ref.message;\n  return [\"\\n    %c\".concat(title, \"\\n    ============================\\n\\n    \").concat(message, \"\\n\\n    ============================\\n    \").replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nvar log$1 = /*#__PURE__*/function () {\n  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_ref2) {\n    var _console2, _console3, _console4, _console5, _console6;\n    var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;\n          _context6.next = 3;\n          return config$1.get(\"logger.level\", LEVELS$1.warn);\n        case 3:\n          configLoggerLevel = _context6.sent;\n          if (!(!always && configLoggerLevel < level)) {\n            _context6.next = 6;\n            break;\n          }\n          return _context6.abrupt(\"return\");\n        case 6:\n          loggerMessageArgs = buildLoggerMessageArgs$1({\n            title: title,\n            message: message\n          });\n          _context6.t0 = level;\n          _context6.next = _context6.t0 === LEVELS$1.debug ? 10 : _context6.t0 === LEVELS$1.info ? 12 : _context6.t0 === LEVELS$1.warn ? 14 : _context6.t0 === LEVELS$1.error ? 16 : 18;\n          break;\n        case 10:\n          (_console2 = console).debug.apply(_console2, _toConsumableArray(loggerMessageArgs));\n          return _context6.abrupt(\"break\", 19);\n        case 12:\n          (_console3 = console).info.apply(_console3, _toConsumableArray(loggerMessageArgs));\n          return _context6.abrupt(\"break\", 19);\n        case 14:\n          (_console4 = console).warn.apply(_console4, _toConsumableArray(loggerMessageArgs));\n          return _context6.abrupt(\"break\", 19);\n        case 16:\n          (_console5 = console).error.apply(_console5, _toConsumableArray(loggerMessageArgs));\n          return _context6.abrupt(\"break\", 19);\n        case 18:\n          (_console6 = console).log.apply(_console6, _toConsumableArray(loggerMessageArgs));\n        case 19:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return function log$1(_x6) {\n    return _ref13.apply(this, arguments);\n  };\n}();\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog$1.deprecate = function (_ref3) {\n  var pkg = _ref3.pkg,\n    subject = _ref3.subject,\n    transition = _ref3.transition,\n    _ref3$level = _ref3.level,\n    level = _ref3$level === void 0 ? LEVELS$1.warn : _ref3$level,\n    _ref3$message = _ref3.message,\n    message = _ref3$message === void 0 ? \"\" : _ref3$message,\n    _ref3$callback = _ref3.callback,\n    callback = _ref3$callback === void 0 ? null : _ref3$callback;\n  var capitalizeFirstLetter = function capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  var logMessage = function logMessage() {\n    return log$1({\n      title: \"\".concat(pkg ? pkg + \" \" : \"\", \"Deprecation Notice\"),\n      message: \"\\n      \".concat(subject ? \"\".concat(capitalizeFirstLetter(subject), \" is deprecated and will cease to work in future releases\").concat(pkg ? \" of \" + pkg : \"\", \".\") : \"\").concat(message ? \"\\n\" + message : \"\").concat(transition ? \"\\nYou can learn more (including a guide on common transition paths) here: \".concat(transition) : \"\", \"\\n    \").trim(),\n      level: level\n    });\n  };\n  if (typeof callback === \"function\") {\n    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n      var _args7 = arguments;\n      return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n        while (1) switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.next = 2;\n            return logMessage();\n          case 2:\n            _context7.next = 4;\n            return callback.apply(void 0, _args7);\n          case 4:\n            return _context7.abrupt(\"return\", _context7.sent);\n          case 5:\n          case \"end\":\n            return _context7.stop();\n        }\n      }, _callee7);\n    }));\n  }\n  return logMessage();\n};\n\n/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nfunction invariant(fact, msg) {\n  if (!fact) {\n    var _console7;\n    var error = new Error(\"INVARIANT \".concat(msg));\n    error.stack = error.stack.split(\"\\n\").filter(function (d) {\n      return !/at invariant/.test(d);\n    }).join(\"\\n\");\n    for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      rest[_key - 2] = arguments[_key];\n    }\n    (_console7 = console).error.apply(_console7, [\"\\n\\n---\\n\\n\", error, \"\\n\\n\"].concat(rest, [\"\\n\\n---\\n\\n\"]));\n    throw error;\n  }\n}\nvar pipe = function pipe() {\n  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return func(res);\n    }, v);\n  };\n};\n\n/***\n * Merge multiple functions returning objects into one object.\n * @param {...function(*): object} funcs - Functions to merge\n * @return {object} - Merged object\n */\nvar mergePipe = function mergePipe() {\n  for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    funcs[_key2] = arguments[_key2];\n  }\n  return function (v) {\n    return funcs.reduce(function (res, func) {\n      return _objectSpread(_objectSpread({}, res), func(v));\n    }, {});\n  };\n};\n\n/**\n * @description Object check\n * @param {*} value - Value to check\n * @returns {boolean} - Is object status\n */\nvar isObject = function isObject(value) {\n  return value && typeof value === \"object\" && !Array.isArray(value);\n};\n\n/**\n * @description Deep merge multiple objects.\n * @param {object} target - Target object\n * @param {...object[]} sources - Source objects\n * @returns {object} - Merged object\n */\nvar mergeDeep = function mergeDeep(target) {\n  for (var _len3 = arguments.length, sources = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    sources[_key3 - 1] = arguments[_key3];\n  }\n  if (!sources.length) return target;\n  var source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (var key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, _defineProperty({}, key, {}));\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, _defineProperty({}, key, source[key]));\n      }\n    }\n  }\n  return mergeDeep.apply(void 0, [target].concat(sources));\n};\n\n/**\n * @description Deep merge multiple Flow JSON.\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {object} - Merged Flow JSON\n */\nvar mergeFlowJSONs = function mergeFlowJSONs(value) {\n  return Array.isArray(value) ? mergeDeep.apply(void 0, [{}].concat(_toConsumableArray(value))) : value;\n};\n\n/**\n * @description Filter out contracts section of flow.json.\n * @param {object|object[]} obj - Flow JSON or array of Flow JSONs\n * @returns {object} - Contracts section of Flow JSON\n */\nvar filterContracts = function filterContracts(obj) {\n  return obj.contracts ? obj.contracts : {};\n};\n\n/**\n * @description Gathers contract addresses by network\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar mapContractAliasesToNetworkAddress = function mapContractAliasesToNetworkAddress(network) {\n  return function (contracts) {\n    return Object.entries(contracts).reduce(function (c, _ref) {\n      var _value$aliases2;\n      var _ref15 = _slicedToArray(_ref, 2),\n        key = _ref15[0],\n        value = _ref15[1];\n      var networkContractAlias = value === null || value === void 0 || (_value$aliases2 = value.aliases) === null || _value$aliases2 === void 0 ? void 0 : _value$aliases2[network];\n      if (networkContractAlias) {\n        c[key] = networkContractAlias;\n      }\n      return c;\n    }, {});\n  };\n};\nvar mapDeploymentsToNetworkAddress = function mapDeploymentsToNetworkAddress(network) {\n  return function (_ref2) {\n    var _ref2$deployments2 = _ref2.deployments,\n      deployments = _ref2$deployments2 === void 0 ? {} : _ref2$deployments2,\n      _ref2$accounts2 = _ref2.accounts,\n      accounts = _ref2$accounts2 === void 0 ? {} : _ref2$accounts2;\n    var networkDeployment = deployments === null || deployments === void 0 ? void 0 : deployments[network];\n    if (!networkDeployment) return {};\n    return Object.entries(networkDeployment).reduce(function (c, _ref3) {\n      var _accounts$key2;\n      var _ref16 = _slicedToArray(_ref3, 2),\n        key = _ref16[0],\n        value = _ref16[1];\n      // Resolve account address\n      var accountAddress = (_accounts$key2 = accounts[key]) === null || _accounts$key2 === void 0 ? void 0 : _accounts$key2.address;\n      if (!accountAddress) return c;\n\n      // Create an object assigning the address to the contract name.\n      return value.reduce(function (c, contract) {\n        return _objectSpread(_objectSpread({}, c), {}, _defineProperty({}, contract, accountAddress));\n      }, {});\n    }, {});\n  };\n};\n\n/**\n * @description Take in flow.json files and return contract to address mapping by network\n * @param {object|object[]} jsons - Flow JSON or array of Flow JSONs\n * @param {string} network - Network to gather addresses for\n * @returns {object} - Contract names by addresses mapping e.g { \"HelloWorld\": \"0x123\" }\n */\nvar getContracts = function getContracts(jsons, network) {\n  return pipe(mergeFlowJSONs, mergePipe(mapDeploymentsToNetworkAddress(network), pipe(filterContracts, mapContractAliasesToNetworkAddress(network))))(jsons);\n};\n\n/**\n * @description Checks if string is hexidecimal\n * @param {string} str - String to check\n * @returns {boolean} - Is hexidecimal status\n */\nvar isHexidecimal = function isHexidecimal(str) {\n  // Check that it is a string\n  if (typeof str !== \"string\") return false;\n  return /^[0-9A-Fa-f]+$/.test(str);\n};\n\n/**\n * @description Checks flow.json file for private keys\n * @param {object} flowJSON - Flow JSON\n * @returns {boolean} - Has private keys status\n */\nvar hasPrivateKeys = function hasPrivateKeys(flowJSON) {\n  return Object.entries(flowJSON === null || flowJSON === void 0 ? void 0 : flowJSON.accounts).reduce(function (hasPrivateKey, _ref4) {\n    var _ref17 = _slicedToArray(_ref4, 2),\n      key = _ref17[0],\n      value = _ref17[1];\n    if (hasPrivateKey) return true;\n    return (value === null || value === void 0 ? void 0 : value.hasOwnProperty(\"key\")) && isHexidecimal(value === null || value === void 0 ? void 0 : value.key);\n  }, false);\n};\n\n/**\n * @description Take in flow.json or array of flow.json files and checks for private keys\n * @param {object|object[]} value - Flow JSON or array of Flow JSONs\n * @returns {boolean} - Has private keys status\n */\nvar anyHasPrivateKeys = function anyHasPrivateKeys(value) {\n  if (isObject(value)) return hasPrivateKeys(value);\n  return value.some(hasPrivateKeys);\n};\n\n/**\n * @description Format network to always be 'emulator', 'testnet', or 'mainnet'\n * @param {string} network - Network to format\n * @returns {string} - Formatted network name (either 'emulator', 'testnet', or 'mainnet')\n */\nvar cleanNetwork = function cleanNetwork(network) {\n  return (network === null || network === void 0 ? void 0 : network.toLowerCase()) === \"local\" ? \"emulator\" : network === null || network === void 0 ? void 0 : network.toLowerCase();\n};\nvar NAME = \"config\";\nvar PUT = \"PUT_CONFIG\";\nvar GET = \"GET_CONFIG\";\nvar GET_ALL = \"GET_ALL_CONFIG\";\nvar UPDATE = \"UPDATE_CONFIG\";\nvar DELETE = \"DELETE_CONFIG\";\nvar CLEAR = \"CLEAR_CONFIG\";\nvar WHERE = \"WHERE_CONFIG\";\nvar UPDATED = \"CONFIG/UPDATED\";\nvar identity = function identity(v) {\n  return v;\n};\nvar HANDLERS = (_HANDLERS = {}, _defineProperty(_HANDLERS, PUT, function (ctx, _letter, _ref) {\n  var key = _ref.key,\n    value = _ref.value;\n  if (key == null) throw new Error(\"Missing 'key' for config/put.\");\n  ctx.put(key, value);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, GET, function (ctx, letter, _ref2) {\n  var key = _ref2.key,\n    fallback = _ref2.fallback;\n  if (key == null) throw new Error(\"Missing 'key' for config/get\");\n  letter.reply(ctx.get(key, fallback));\n}), _defineProperty(_HANDLERS, GET_ALL, function (ctx, letter) {\n  letter.reply(_objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, UPDATE, function (ctx, letter, _ref3) {\n  var key = _ref3.key,\n    fn = _ref3.fn;\n  if (key == null) throw new Error(\"Missing 'key' for config/update\");\n  ctx.update(key, fn || identity);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, DELETE, function (ctx, letter, _ref4) {\n  var key = _ref4.key;\n  if (key == null) throw new Error(\"Missing 'key' for config/delete\");\n  ctx.delete(key);\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, CLEAR, function (ctx, letter) {\n  var keys = Object.keys(ctx.all());\n  for (var _i2 = 0, _keys2 = keys; _i2 < _keys2.length; _i2++) {\n    var key = _keys2[_i2];\n    ctx.delete(key);\n  }\n  ctx.broadcast(UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, WHERE, function (ctx, letter, _ref5) {\n  var pattern = _ref5.pattern;\n  if (pattern == null) throw new Error(\"Missing 'pattern' for config/where\");\n  letter.reply(ctx.where(pattern));\n}), _defineProperty(_HANDLERS, SUBSCRIBE, function (ctx, letter) {\n  ctx.subscribe(letter.from);\n  ctx.send(letter.from, UPDATED, _objectSpread({}, ctx.all()));\n}), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {\n  ctx.unsubscribe(letter.from);\n}), _HANDLERS);\nspawn(HANDLERS, NAME);\n\n/**\n * @description Adds a key-value pair to the config\n * @param {string} key - The key to add\n * @param {*} value - The value to add\n * @returns {Promise<object>} - The current config\n */\nfunction put(key, value) {\n  _send(NAME, PUT, {\n    key: key,\n    value: value\n  });\n  return config();\n}\n\n/**\n * @description Gets a key-value pair with a fallback from the config\n * @param {string} key - The key to add\n * @param {*} [fallback] - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction get(key, fallback) {\n  return _send(NAME, GET, {\n    key: key,\n    fallback: fallback\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Returns the first non null config value or the fallback\n * @param {string[]} wants - The keys to search for\n * @param {*} fallback - The fallback value to return if key is not found\n * @returns {Promise<*>} - The value found at key or fallback\n */\nfunction first() {\n  return _first.apply(this, arguments);\n}\n/**\n * @description Returns the current config\n * @returns {Promise<object>} - The current config\n */\nfunction _first() {\n  _first = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n    var wants,\n      fallback,\n      _wants2,\n      head,\n      rest,\n      ret,\n      _args13 = arguments;\n    return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n      while (1) switch (_context13.prev = _context13.next) {\n        case 0:\n          wants = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : [];\n          fallback = _args13.length > 1 ? _args13[1] : undefined;\n          if (wants.length) {\n            _context13.next = 4;\n            break;\n          }\n          return _context13.abrupt(\"return\", fallback);\n        case 4:\n          _wants2 = _toArray(wants), head = _wants2[0], rest = _wants2.slice(1);\n          _context13.next = 7;\n          return get(head);\n        case 7:\n          ret = _context13.sent;\n          if (!(ret == null)) {\n            _context13.next = 10;\n            break;\n          }\n          return _context13.abrupt(\"return\", first(rest, fallback));\n        case 10:\n          return _context13.abrupt(\"return\", ret);\n        case 11:\n        case \"end\":\n          return _context13.stop();\n      }\n    }, _callee13);\n  }));\n  return _first.apply(this, arguments);\n}\nfunction all() {\n  return _send(NAME, GET_ALL, null, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Updates a key-value pair in the config\n * @param {string} key - The key to update\n * @param {Function} fn - The function to update the value with\n * @returns {Promise<object>} - The current config\n */\nfunction update(key) {\n  var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n  _send(NAME, UPDATE, {\n    key: key,\n    fn: fn\n  });\n  return config();\n}\n\n/**\n * @description Deletes a key-value pair from the config\n * @param {string} key - The key to delete\n * @returns {Promise<object>} - The current config\n */\nfunction _delete(key) {\n  _send(NAME, DELETE, {\n    key: key\n  });\n  return config();\n}\n\n/**\n * @description Returns a subset of the config based on a pattern\n * @param {string} pattern - The pattern to match keys against\n * @returns {Promise<object>} - The subset of the config\n */\nfunction where(pattern) {\n  return _send(NAME, WHERE, {\n    pattern: pattern\n  }, {\n    expectReply: true,\n    timeout: 10\n  });\n}\n\n/**\n * @description Subscribes to config updates\n * @param {Function} callback - The callback to call when config is updated\n * @returns {Function} - The unsubscribe function\n */\nfunction subscribe(callback) {\n  return subscriber(NAME, function () {\n    return spawn(HANDLERS, NAME);\n  }, callback);\n}\n\n/**\n * @description Clears the config\n * @returns {void}\n */\nfunction clearConfig() {\n  return _send(NAME, CLEAR);\n}\n\n/**\n * @description Resets the config to a previous state\n * @param {object} oldConfig - The previous config state\n * @returns {Promise<object>} - The current config\n */\nfunction resetConfig(oldConfig) {\n  return clearConfig().then(config(oldConfig));\n}\n\n/**\n * @description Takes in flow.json or array of flow.json files and creates contract placeholders\n * @param {object|object[]} data - The flow.json or array of flow.json files\n * @returns {void}\n */\nfunction load(_x7) {\n  return _load.apply(this, arguments);\n} // eslint-disable-next-line jsdoc/require-returns\n/**\n * @description Sets the config\n * @param {object} [values] - The values to set\n */\nfunction _load() {\n  _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(data) {\n    var network, cleanedNetwork, flowJSON, isEmulator, _i4, _Object$entries2, _Object$entries2$_i, key, value, contractConfigKey, existingContractConfigKey, systemContractConfigKey, systemExistingContractConfigKeyValue;\n    return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n      while (1) switch (_context14.prev = _context14.next) {\n        case 0:\n          _context14.next = 2;\n          return get(\"flow.network\");\n        case 2:\n          network = _context14.sent;\n          cleanedNetwork = cleanNetwork(network);\n          flowJSON = data.flowJSON;\n          invariant(Boolean(flowJSON), \"config.load -- 'flowJSON' must be defined\");\n          invariant(cleanedNetwork, \"Flow Network Required -- In order for FCL to load your contracts please define \\\"flow.network\\\" to \\\"emulator\\\", \\\"local\\\", \\\"testnet\\\", or \\\"mainnet\\\" in your config. See more here: https://developers.flow.com/tools/fcl-js/reference/configure-fcl\");\n          if (!anyHasPrivateKeys(flowJSON)) {\n            _context14.next = 12;\n            break;\n          }\n          isEmulator = cleanedNetwork === \"emulator\";\n          log$1({\n            title: \"Private Keys Detected\",\n            message: \"Private keys should be stored in a separate flow.json file for security. See more here: https://developers.flow.com/tools/flow-cli/security\",\n            level: isEmulator ? LEVELS$1.warn : LEVELS$1.error\n          });\n          if (isEmulator) {\n            _context14.next = 12;\n            break;\n          }\n          return _context14.abrupt(\"return\");\n        case 12:\n          _i4 = 0, _Object$entries2 = Object.entries(getContracts(flowJSON, cleanedNetwork));\n        case 13:\n          if (!(_i4 < _Object$entries2.length)) {\n            _context14.next = 28;\n            break;\n          }\n          _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2), key = _Object$entries2$_i[0], value = _Object$entries2$_i[1];\n          contractConfigKey = \"0x\".concat(key);\n          _context14.next = 18;\n          return get(contractConfigKey);\n        case 18:\n          existingContractConfigKey = _context14.sent;\n          if (existingContractConfigKey && existingContractConfigKey !== value) {\n            log$1({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS$1.warn\n            });\n          } else {\n            put(contractConfigKey, value);\n          }\n          systemContractConfigKey = \"system.contracts.\".concat(key);\n          _context14.next = 23;\n          return get(systemContractConfigKey);\n        case 23:\n          systemExistingContractConfigKeyValue = _context14.sent;\n          if (systemExistingContractConfigKeyValue && systemExistingContractConfigKeyValue !== value) {\n            log$1({\n              title: \"Contract Placeholder Conflict Detected\",\n              message: \"A generated contract placeholder from config.load conflicts with a placeholder you've set manually in config have the same name.\",\n              level: LEVELS$1.warn\n            });\n          } else {\n            put(systemContractConfigKey, value);\n          }\n        case 25:\n          _i4++;\n          _context14.next = 13;\n          break;\n        case 28:\n        case \"end\":\n          return _context14.stop();\n      }\n    }, _callee14);\n  }));\n  return _load.apply(this, arguments);\n}\nfunction config(values) {\n  if (values != null && typeof values === \"object\") {\n    Object.keys(values).map(function (d) {\n      return put(d, values[d]);\n    });\n  }\n  return {\n    put: put,\n    get: get,\n    all: all,\n    first: first,\n    update: update,\n    delete: _delete,\n    where: where,\n    subscribe: subscribe,\n    overload: overload,\n    load: load\n  };\n}\nconfig.put = put;\nconfig.get = get;\nconfig.all = all;\nconfig.first = first;\nconfig.update = update;\nconfig.delete = _delete;\nconfig.where = where;\nconfig.subscribe = subscribe;\nconfig.overload = overload;\nconfig.load = load;\nvar noop = function noop(v) {\n  return v;\n};\nfunction overload() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  return new Promise( /*#__PURE__*/function () {\n    var _ref18 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(resolve, reject) {\n      var oldConfig, result;\n      return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n        while (1) switch (_context8.prev = _context8.next) {\n          case 0:\n            _context8.next = 2;\n            return all();\n          case 2:\n            oldConfig = _context8.sent;\n            _context8.prev = 3;\n            config(opts);\n            _context8.t0 = callback;\n            _context8.next = 8;\n            return all();\n          case 8:\n            _context8.t1 = _context8.sent;\n            _context8.next = 11;\n            return (0, _context8.t0)(_context8.t1);\n          case 11:\n            result = _context8.sent;\n            _context8.next = 14;\n            return resetConfig(oldConfig);\n          case 14:\n            resolve(result);\n            _context8.next = 22;\n            break;\n          case 17:\n            _context8.prev = 17;\n            _context8.t2 = _context8[\"catch\"](3);\n            _context8.next = 21;\n            return resetConfig(oldConfig);\n          case 21:\n            reject(_context8.t2);\n          case 22:\n          case \"end\":\n            return _context8.stop();\n        }\n      }, _callee8, null, [[3, 17]]);\n    }));\n    return function (_x8, _x9) {\n      return _ref18.apply(this, arguments);\n    };\n  }());\n}\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nvar LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1\n});\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nvar buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {\n  var title = _ref.title,\n    message = _ref.message;\n  return [\"\\n    %c\".concat(title, \"\\n    ============================\\n\\n    \").concat(message, \"\\n\\n    ============================\\n    \").replace(/\\n[^\\S\\r\\n]+/g, \"\\n\").trim(),, \"font-weight:bold;font-family:monospace;\"];\n};\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nvar log = /*#__PURE__*/function () {\n  var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_ref2) {\n    var _console8, _console9, _console10, _console11, _console12;\n    var title, message, level, _ref2$always2, always, configLoggerLevel, loggerMessageArgs;\n    return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n      while (1) switch (_context9.prev = _context9.next) {\n        case 0:\n          title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always2 = _ref2.always, always = _ref2$always2 === void 0 ? false : _ref2$always2;\n          _context9.next = 3;\n          return config.get(\"logger.level\", LEVELS.warn);\n        case 3:\n          configLoggerLevel = _context9.sent;\n          if (!(!always && configLoggerLevel < level)) {\n            _context9.next = 6;\n            break;\n          }\n          return _context9.abrupt(\"return\");\n        case 6:\n          loggerMessageArgs = buildLoggerMessageArgs({\n            title: title,\n            message: message\n          });\n          _context9.t0 = level;\n          _context9.next = _context9.t0 === LEVELS.debug ? 10 : _context9.t0 === LEVELS.info ? 12 : _context9.t0 === LEVELS.warn ? 14 : _context9.t0 === LEVELS.error ? 16 : 18;\n          break;\n        case 10:\n          (_console8 = console).debug.apply(_console8, _toConsumableArray(loggerMessageArgs));\n          return _context9.abrupt(\"break\", 19);\n        case 12:\n          (_console9 = console).info.apply(_console9, _toConsumableArray(loggerMessageArgs));\n          return _context9.abrupt(\"break\", 19);\n        case 14:\n          (_console10 = console).warn.apply(_console10, _toConsumableArray(loggerMessageArgs));\n          return _context9.abrupt(\"break\", 19);\n        case 16:\n          (_console11 = console).error.apply(_console11, _toConsumableArray(loggerMessageArgs));\n          return _context9.abrupt(\"break\", 19);\n        case 18:\n          (_console12 = console).log.apply(_console12, _toConsumableArray(loggerMessageArgs));\n        case 19:\n        case \"end\":\n          return _context9.stop();\n      }\n    }, _callee9);\n  }));\n  return function log(_x10) {\n    return _ref19.apply(this, arguments);\n  };\n}();\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = function (_ref3) {\n  var pkg = _ref3.pkg,\n    subject = _ref3.subject,\n    transition = _ref3.transition,\n    _ref3$level2 = _ref3.level,\n    level = _ref3$level2 === void 0 ? LEVELS.warn : _ref3$level2,\n    _ref3$message2 = _ref3.message,\n    message = _ref3$message2 === void 0 ? \"\" : _ref3$message2,\n    _ref3$callback2 = _ref3.callback,\n    callback = _ref3$callback2 === void 0 ? null : _ref3$callback2;\n  var capitalizeFirstLetter = function capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n  };\n  var logMessage = function logMessage() {\n    return log({\n      title: \"\".concat(pkg ? pkg + \" \" : \"\", \"Deprecation Notice\"),\n      message: \"\\n      \".concat(subject ? \"\".concat(capitalizeFirstLetter(subject), \" is deprecated and will cease to work in future releases\").concat(pkg ? \" of \" + pkg : \"\", \".\") : \"\").concat(message ? \"\\n\" + message : \"\").concat(transition ? \"\\nYou can learn more (including a guide on common transition paths) here: \".concat(transition) : \"\", \"\\n    \").trim(),\n      level: level\n    });\n  };\n  if (typeof callback === \"function\") {\n    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n      var _args10 = arguments;\n      return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n        while (1) switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return logMessage();\n          case 2:\n            _context10.next = 4;\n            return callback.apply(void 0, _args10);\n          case 4:\n            return _context10.abrupt(\"return\", _context10.sent);\n          case 5:\n          case \"end\":\n            return _context10.stop();\n        }\n      }, _callee10);\n    }));\n  }\n  return logMessage();\n};\nfunction interleave() {\n  var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (!a.length && !b.length) return c;\n  if (!a.length) return c;\n  if (!b.length) return [].concat(_toConsumableArray(c), [a[0]]);\n  var _a = _toArray(a),\n    aHead = _a[0],\n    aRest = _a.slice(1);\n  var _b = _toArray(b),\n    bHead = _b[0],\n    bRest = _b.slice(1);\n  if (aHead !== undefined) c.push(aHead);\n  if (bHead !== undefined) c.push(bHead);\n  return interleave(aRest, bRest, c);\n}\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition: \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\"\n      });\n      return recApply(d)(arg1(d));\n    }\n    return String(arg1);\n  };\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nfunction template(head) {\n  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    rest[_key - 1] = arguments[_key];\n  }\n  if (typeof head === \"string\") return function () {\n    return head;\n  };\n  if (Array.isArray(head)) {\n    return function (d) {\n      return interleave(head, rest.map(recApply(d))).join(\"\").trim();\n    };\n  }\n  return head;\n}\nexport { interleave, template };","map":{"version":3,"names":["promise","queueMicrotask_1","queueMicrotask","bind","window","commonjsGlobal","cb","Promise","resolve","then","catch","err","setTimeout","next","deliver","msg","_asyncToGenerator","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","queue","push","shift","undefined","stop","receive","innerReceive","fact","_console","error","Error","concat","stack","split","filter","d","test","join","console","apply","rest","invariant","_console7","_len","arguments","length","Array","_key","LEVELS","Object","freeze","debug","info","log","warn","buildLoggerMessageArgs","_ref","title","message","replace","trim","_ref19","_callee9","_ref2","_console8","_console9","_console10","_console11","_console12","level","_ref2$always2","always","configLoggerLevel","loggerMessageArgs","_callee9$","_context9","config","get","sent","abrupt","t0","_toConsumableArray","_x10","deprecate","_ref3","pkg","subject","transition","_ref3$level2","_ref3$message2","_ref3$callback2","callback","capitalizeFirstLetter","string","charAt","toUpperCase","slice","logMessage","interleave","a","b","c","_a","_toArray","aHead","aRest","_b","bHead","bRest","recApply","arg1","String","template","head","isArray","map"],"sources":["/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/node_modules/queue-microtask/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-actor/src/mailbox/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-invariant/src/index.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-logger/src/util-logger.js","/Users/oqpo/Documents/GitHub/darkblock-flow/node_modules/@onflow/util-template/src/template.js"],"sourcesContent":["/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask.bind(typeof window !== 'undefined' ? window : global)\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","export const mailbox = () => {\n  const queue = []\n  var next\n\n  return {\n    async deliver(msg) {\n      queue.push(msg)\n      if (next) {\n        next(queue.shift())\n        next = undefined\n      }\n    },\n\n    receive() {\n      return new Promise(function innerReceive(resolve) {\n        const msg = queue.shift()\n        if (msg) return resolve(msg)\n        next = resolve\n      })\n    },\n  }\n}\n","/**\n * Asserts fact is true, otherwise throw an error with invariant message\n * @param {boolean} fact\n * @param {string} msg\n * @param {Array} rest\n * @returns {void}\n */\nexport function invariant(fact, msg, ...rest) {\n  if (!fact) {\n    const error = new Error(`INVARIANT ${msg}`)\n    error.stack = error.stack\n      .split(\"\\n\")\n      .filter(d => !/at invariant/.test(d))\n      .join(\"\\n\")\n    console.error(\"\\n\\n---\\n\\n\", error, \"\\n\\n\", ...rest, \"\\n\\n---\\n\\n\")\n    throw error\n  }\n}\n","import {config} from \"@onflow/config\"\n\n/**\n * The levels of the logger\n * \n * @typedef {Object} LEVELS\n * @property {number} debug - The debug level\n * @property {number} info - The info level\n * @property {number} log - The log level\n * @property {number} warn - The warn level\n * @property {number} error - The error level\n * \n */\nexport const LEVELS = Object.freeze({\n  debug: 5,\n  info: 4,\n  log: 3,\n  warn: 2,\n  error: 1,\n})\n\n/**\n * Builds a message formatted for the logger\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @returns {Array<string>} - The message formatted for the logger\n * \n * @example\n * buildLoggerMessageArgs({ title: \"My Title\", message: \"My Message\" })\n */\nconst buildLoggerMessageArgs = ({title, message}) => {\n  return [\n    `\n    %c${title}\n    ============================\n\n    ${message}\n\n    ============================\n    `\n      .replace(/\\n[^\\S\\r\\n]+/g, \"\\n\")\n      .trim(),\n    ,\n    \"font-weight:bold;font-family:monospace;\",\n  ]\n}\n\n/**\n * Logs messages based on the level of the message and the level set in the config\n * \n * @param {Object} options - The options for the log\n * @param {string} options.title - The title of the log\n * @param {string} options.message - The message of the log\n * @param {number} options.level - The level of the log\n * @param {boolean} options.always - Whether to always show the log\n * @returns {Promise<void>}\n * \n * @example\n * log({ title: \"My Title\", message: \"My Message\", level: LEVELS.warn, always: false })\n * \n */\nexport const log = async ({title, message, level, always = false}) => {\n  const configLoggerLevel = await config.get(\"logger.level\", LEVELS.warn)\n\n  // If config level is below message level then don't show it\n  if (!always && configLoggerLevel < level) return\n\n  const loggerMessageArgs = buildLoggerMessageArgs({title, message})\n\n  switch (level) {\n    case LEVELS.debug:\n      console.debug(...loggerMessageArgs)\n      break\n    case LEVELS.info:\n      console.info(...loggerMessageArgs)\n      break\n    case LEVELS.warn:\n      console.warn(...loggerMessageArgs)\n      break\n    case LEVELS.error:\n      console.error(...loggerMessageArgs)\n      break\n    default:\n      console.log(...loggerMessageArgs)\n  }\n}\n\n/**\n * Logs a deprecation notice\n * \n * @param {Object} options - The options for the log\n * @param {string} options.pkg - The package that is being deprecated\n * @param {string} options.subject - The subject of the deprecation\n * @param {string} options.transition - The transition path for the deprecation\n * @param {number} options.level - The level of the log\n * @param {string} options.message - The message of the log\n * @param {Function} options.callback - A callback to run after the log\n * @returns {Promise<void>}\n * \n * @example\n * log.deprecate({ pkg: \"@onflow/fcl\", subject: \"Some item\", transition: \"https://github.com/onflow/flow-js-sdk\", message: \"Descriptive message\", level: LEVELS.warn, callback: () => {} })\n * \n */\nlog.deprecate = ({\n  pkg,\n  subject,\n  transition,\n  level = LEVELS.warn,\n  message = \"\",\n  callback = null,\n}) => {\n  const capitalizeFirstLetter = string => {\n    return string.charAt(0).toUpperCase() + string.slice(1)\n  }\n\n  const logMessage = () =>\n    log({\n      title: `${pkg ? pkg + \" \" : \"\"}Deprecation Notice`,\n      message: `\n      ${\n        subject\n          ? `${capitalizeFirstLetter(\n              subject\n            )} is deprecated and will cease to work in future releases${\n              pkg ? \" of \" + pkg : \"\"\n            }.`\n          : \"\"\n      }${message ? \"\\n\" + message : \"\"}${\n        transition\n          ? `\\nYou can learn more (including a guide on common transition paths) here: ${transition}`\n          : \"\"\n      }\n    `.trim(),\n      level,\n    })\n\n  if (typeof callback === \"function\") {\n    return async (...args) => {\n      await logMessage()\n      return await callback(...args)\n    }\n  }\n  return logMessage()\n}\n","import {log} from \"@onflow/util-logger\"\n\nexport function interleave(a = [], b = [], c = []) {\n  if (!a.length && !b.length) return c\n  if (!a.length) return c\n  if (!b.length) return [...c, a[0]]\n\n  const [aHead, ...aRest] = a\n  const [bHead, ...bRest] = b\n\n  if (aHead !== undefined) c.push(aHead)\n  if (bHead !== undefined) c.push(bHead)\n\n  return interleave(aRest, bRest, c)\n}\n\nfunction recApply(d) {\n  return function (arg1) {\n    if (typeof arg1 === \"function\") {\n      log.deprecate({\n        pkg: \"FCL/SDK\",\n        subject: \"Interopolation of functions into template literals\",\n        transition:\n          \"https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params\",\n      })\n      return recApply(d)(arg1(d))\n    }\n    return String(arg1)\n  }\n}\n\n/**\n * @param {(string|Array.<*>)} head\n * @param {Array.<*>} rest\n * @returns {{function(): string}}\n */\nexport function template(head, ...rest) {\n  if (typeof head === \"string\") return () => head\n  if (Array.isArray(head)) {\n    return d =>\n      interleave(head, rest.map(recApply(d)))\n        .join(\"\")\n        .trim()\n  }\n  return head\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}